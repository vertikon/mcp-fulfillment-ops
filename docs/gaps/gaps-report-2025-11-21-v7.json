{
  "project_name": "mcp-fulfillment-ops",
  "project_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops",
  "timestamp": "2025-11-21 16:18:01",
  "validator_version": "9.4",
  "critical": [
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(generateCmd)\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\n    49 | }\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(generateCmd)\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n\tgenerateCmd.MarkFlagRequired(\"template\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\n    20 | \t\treturn nil\n    21 | \t},\n    22 | }\n    23 | \nâ†’   24 | func init() {\n    25 | \trootCmd.AddCommand(monitorCmd)\n    26 | }\n    27 | \n    28 | // SetMonitoringService sets the monitoring service\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(monitorCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 38,
          "code_snippet": "    33 | \t\tos.Exit(1)\n    34 | \t}\n    35 | }\n    36 | \n    37 | // init initializes the CLI\nâ†’   38 | func init() {\n    39 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    40 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    41 | \n    42 | \t// Add subcommand groups\n    43 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\t// ci.CICmd removido - pacote ci nÃ£o existe ainda\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/cli/analytics",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\n    16 | \t\treturn nil\n    17 | \t},\n    18 | }\n    19 | \nâ†’   20 | func init() {\n    21 | \trootCmd.AddCommand(stateCmd)\n    22 | }\n    23 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(stateCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(templateCmd)\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(templateCmd)\n\ttemplateCmd.AddCommand(templateListCmd)\n\ttemplateCmd.AddCommand(templateCreateCmd)\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\n    18 | \t},\n    19 | }\n    20 | \nâ†’   21 | func init() {\n    22 | \trootCmd.AddCommand(versionCmd)\n    23 | }\n    24 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(versionCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\n    19 | \t\treturn nil\n    20 | \t},\n    21 | }\n    22 | \nâ†’   23 | func init() {\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\n    25 | }\n    26 | \n",
          "full_function": "func init() {\n\tAnalyticsCmd.AddCommand(performanceCmd)\n}",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-fulfillment-ops/internal/mcp/protocol\ninternal\\mcp\\protocol\\handlers.go:344:4: h.parseParams undefined (type *ListTemplatesHandler has no field or method parseParams)\ninterna...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\docs\\validation\\raw\\2025-11-21-16-16-07-compilation.log",
        "",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/mcp/protocol",
        "internal\\mcp\\protocol\\handlers.go:344:4: h.parseParams undefined (type *ListTemplatesHandler has no field or method parseParams)",
        "internal\\mcp\\protocol\\handlers.go:446:4: h.parseParams undefined (type *ListProjectsHandler has no field or method parseParams)",
        "# github.com/vertikon/mcp-fulfillment-ops/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\" imported and not used",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/security/config",
        "internal\\security\\config\\integration.go:215:26: ruleCfg.Resource undefined (type PolicyRuleConfig has no field or method Resource)",
        "internal\\security\\config\\integration.go:216:26: ruleCfg.Action undefined (type PolicyRuleConfig has no field or method Action)",
        "internal\\security\\config\\integration.go:218:26: ruleCfg.Description undefined (type PolicyRuleConfig has no field or method Description)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\protocol\\handlers.go",
          "line_number": 344,
          "code_snippet": "   339 | \tvar params struct {\n   340 | \t\tStack    string `json:\"stack,omitempty\"`\n   341 | \t\tCategory string `json:\"category,omitempty\"`\n   342 | \t}\n   343 | \nâ†’  344 | \th.parseParams(request.Params, \u0026params)\n   345 | \n   346 | \ttemplates, err := h.registry.ListTemplates(registry.TemplateFilter{\n   347 | \t\tStack:    params.Stack,\n   348 | \t\tCategory: params.Category,\n   349 | \t})\n",
          "full_function": "\th.parseParams(request.Params, \u0026params)\n\n\ttemplates, err := h.registry.ListTemplates(registry.TemplateFilter{\n\t\tStack:    params.Stack,\n\t\tCategory: params.Category,\n\t})",
          "symbol_name": "",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "os",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/registry",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/validators",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\protocol\\handlers.go",
          "line_number": 446,
          "code_snippet": "   441 | \tvar params struct {\n   442 | \t\tStack  string `json:\"stack,omitempty\"`\n   443 | \t\tStatus string `json:\"status,omitempty\"`\n   444 | \t}\n   445 | \nâ†’  446 | \th.parseParams(request.Params, \u0026params)\n   447 | \n   448 | \tprojects, err := h.registry.ListProjects(registry.ProjectFilter{\n   449 | \t\tStack:  params.Stack,\n   450 | \t\tStatus: params.Status,\n   451 | \t})\n",
          "full_function": "\th.parseParams(request.Params, \u0026params)\n\n\tprojects, err := h.registry.ListProjects(registry.ProjectFilter{\n\t\tStack:  params.Stack,\n\t\tStatus: params.Status,\n\t})",
          "symbol_name": "",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "os",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/registry",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/validators",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\n     6 | \t\"os\"\n     7 | \t\"path/filepath\"\n     8 | \t\"time\"\n     9 | \nâ†’   10 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n    11 | \t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n    12 | \t\"go.uber.org/zap\"\n    13 | )\n    14 | \n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n",
          "full_function": "\t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\ntype HybridDeployer struct {\n\tdockerDeployer     *DockerDeployer\n\tkubernetesDeployer *KubernetesDeployer\n\tserverlessDeployer *ServerlessDeployer\n\tlogger             *zap.Logger\n}",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\n    10 | \t// Invoke invokes a cloud function\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\n    12 | \n    13 | \t// CreateFunction creates a cloud function\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\n    15 | \n    16 | \t// DeleteFunction deletes a cloud function\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\n    18 | }\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 215,
          "code_snippet": "   210 | \t\t\tif ruleCfg.Effect == \"deny\" {\n   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\nâ†’  215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\nâ†’  216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 218,
          "code_snippet": "   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\nâ†’  218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n   222 | \t\t\t}\n   223 | \t\t\tpolicy.Rules = append(policy.Rules, rule)\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\n   158 | \tcm.stats.InvalidationsByReason[reason]++\n   159 | \tcm.mu.Unlock()\n   160 | \n   161 | \t// Delete from cache\nâ†’  162 | \tcm.cache.Delete(key)\n   163 | \n   164 | \t// Create invalidation event\n   165 | \tevent := \u0026InvalidationEvent{\n   166 | \t\tKey:       key,\n   167 | \t\tReason:    reason,\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\n\tstart := time.Now()\n\n\tcm.mu.Lock()\n\tcm.stats.TotalInvalidations++\n\tcm.stats.InvalidationsByReason[reason]++\n\tcm.mu.Unlock()\n\n\t// Delete from cache\n\tcm.cache.Delete(key)\n\n\t// Create invalidation event\n\tevent := \u0026InvalidationEvent{\n\t\tKey:       key,\n\t\tReason:    reason,\n\t\tTimestamp: time.Now(),\n\t\tSource:    \"coherency_manager\",\n\t}\n\n\t// Send to invalidation channel\n\tselect {\n\tcase cm.invalidationCh \u003c- event:\n\tdefault:\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\n\t\t\tzap.String(\"key\", key))\n\t}\n\n\tcm.mu.Lock()\n\tcm.stats.AverageInvalidationTime = time.Since(start)\n\tlastTime := time.Now()\n\tcm.stats.LastInvalidation = \u0026lastTime\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Cache key invalidated\",\n\t\tzap.String(\"key\", key),\n\t\tzap.String(\"reason\", reason))\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\n   213 | \n   214 | // Update updates a cache entry\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\n   216 | \tcm.mu.Lock()\nâ†’  217 | \tcm.stats.TotalUpdates++\n   218 | \tcm.mu.Unlock()\n   219 | \n   220 | \t// Update cache based on strategy\n   221 | \tswitch cm.config.Strategy {\n   222 | \tcase CoherencyStrategyWriteThrough:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\n   249 | \t\tLevel:                cm.config.Level,\n   250 | \t\tIsCoherent:           true, // Simplified\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\n   254 | \t}, nil\n   255 | }\n   256 | \n   257 | // GetInvalidationStats returns invalidation statistics\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\treturn \u0026CoherencyStatus{\n\t\tStrategy:             cm.config.Strategy,\n\t\tLevel:                cm.config.Level,\n\t\tIsCoherent:           true, // Simplified\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\n   338 | \tcm.pendingInvalidations[event.Key] = event\n   339 | \tcm.mu.Unlock()\n   340 | \n   341 | \t// Process invalidation\nâ†’  342 | \tcm.cache.Delete(event.Key)\n   343 | \n   344 | \tcm.mu.Lock()\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\n   346 | \tcm.mu.Unlock()\n   347 | \n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\n\tcm.mu.Lock()\n\tcm.pendingInvalidations[event.Key] = event\n\tcm.mu.Unlock()\n\n\t// Process invalidation\n\tcm.cache.Delete(event.Key)\n\n\tcm.mu.Lock()\n\tdelete(cm.pendingInvalidations, event.Key)\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Invalidation processed\",\n\t\tzap.String(\"key\", event.Key),\n\t\tzap.String(\"reason\", event.Reason))\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\n   245 | \n   246 | // ReplayFromSnapshot replays events from a snapshot version\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n   248 | \t// Get snapshot\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n   250 | \tif err != nil {\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n   252 | \t}\n   253 | \n   254 | \t// Get events after snapshot version\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n\t// Get snapshot\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n\t}\n\n\t// Get events after snapshot version\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\n\t}\n\n\tif len(events) == 0 {\n\t\treturn \u0026ReplayProgress{\n\t\t\tTotalEvents:     0,\n\t\t\tProcessedEvents: 0,\n\t\t\tIsComplete:      true,\n\t\t}, nil\n\t}\n\n\tstartTime := time.Now()\n\tprogress := \u0026ReplayProgress{\n\t\tTotalEvents:    int64(len(events)),\n\t\tStartTime:      startTime,\n\t\tCurrentVersion: snapshotVersion + 1,\n\t}\n\n\terr = er.replaySequential(ctx, events, handler, progress)\n\tprogress.ElapsedTime = time.Since(startTime)\n\tprogress.IsComplete = true\n\n\tif err != nil {\n\t\tprogress.LastError = err.Error()\n\t\treturn progress, err\n\t}\n\n\treturn progress, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\n   286 | \n   287 | // ReplayToState replays events to rebuild state at a specific version\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\n   289 | \t// Get all events up to target version\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\n   291 | \tif err != nil {\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\n   293 | \t}\n   294 | \n   295 | \t// Replay events\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\n   136 | \t\t// Return copy\n   137 | \t\tcopy := *versionInfo\n   138 | \t\tif versionInfo.VersionHistory != nil {\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n   141 | \t\t}\n   142 | \t\treturn \u0026copy, nil\n   143 | \t}\n   144 | \n   145 | \t// Load from event store\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\n\tev.mu.RLock()\n\tversionInfo, exists := ev.versions[aggregateID]\n\tev.mu.RUnlock()\n\n\tif exists {\n\t\t// Return copy\n\t\tcopy := *versionInfo\n\t\tif versionInfo.VersionHistory != nil {\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n\t\t}\n\t\treturn \u0026copy, nil\n\t}\n\n\t// Load from event store\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t}\n\n\tversionInfo = \u0026VersionInfo{\n\t\tAggregateID:    aggregateID,\n\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\tCurrentVersion: aggregateInfo.Version,\n\t\tMetadata:       make(map[string]interface{}),\n\t}\n\n\tif ev.config.EnableHistory {\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t}\n\n\tev.mu.Lock()\n\tev.versions[aggregateID] = versionInfo\n\tev.mu.Unlock()\n\n\treturn versionInfo, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n   213 | \t\t}\n   214 | \n   215 | \t\t// Resolve conflict\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n   217 | \t\tif err != nil {\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n   219 | \t\t}\n   220 | \n   221 | \t\tnewVersion = resolvedVersion\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\n\tev.mu.Lock()\n\tdefer ev.mu.Unlock()\n\n\tversionInfo, exists := ev.versions[aggregateID]\n\tif !exists {\n\t\t// Load from store\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t\t}\n\n\t\tversionInfo = \u0026VersionInfo{\n\t\t\tAggregateID:    aggregateID,\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\t\tCurrentVersion: aggregateInfo.Version,\n\t\t\tMetadata:       make(map[string]interface{}),\n\t\t}\n\n\t\tif ev.config.EnableHistory {\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t\t}\n\n\t\tev.versions[aggregateID] = versionInfo\n\t}\n\n\t// Increment version\n\tnewVersion := versionInfo.CurrentVersion + 1\n\n\t// Validate version continuity\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\n\t\tconflict := \u0026VersionConflict{\n\t\t\tAggregateID:     aggregateID,\n\t\t\tExpectedVersion: newVersion,\n\t\t\tActualVersion:   event.Version,\n\t\t\tConflictTime:    time.Now(),\n\t\t}\n\n\t\tev.stats.TotalConflicts++\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\n\n\t\tif ev.config.ConflictResolution == \"reject\" {\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n\t\t}\n\n\t\t// Resolve conflict\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n\t\t}\n\n\t\tnewVersion = resolvedVersion\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\n\t\tev.stats.ResolvedConflicts++\n\t}\n\n\t// Update version info\n\tversionInfo.CurrentVersion = newVersion\n\tversionInfo.LastEventID = event.ID\n\tversionInfo.LastEventTime = event.Timestamp\n\n\t// Add to history\n\tif ev.config.EnableHistory {\n\t\tentry := VersionHistoryEntry{\n\t\t\tVersion:   newVersion,\n\t\t\tEventID:   event.ID,\n\t\t\tTimestamp: event.Timestamp,\n\t\t\tEventType: event.Type,\n\t\t}\n\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\n\n\t\t// Trim history if needed\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\n\t\t}\n\t}\n\n\t// Update statistics\n\tev.stats.TotalVersions++\n\tev.stats.VersionDistribution[newVersion]++\n\n\tev.logger.Debug(\"Version incremented\",\n\t\tzap.String(\"aggregate_id\", aggregateID),\n\t\tzap.Int64(\"version\", newVersion))\n\n\treturn newVersion, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\n   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n   242 | \tdefault:\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\n   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n   257 | \n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n   279 | \t// For simple values, use last-write-wins\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\n   281 | \n   282 | \t// Check if values are mergeable\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n   285 | \t\tif err != nil {\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\n   288 | \t\t\t\tzap.Error(err))\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n\t// For simple values, use last-write-wins\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\n\n\t// Check if values are mergeable\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n\t\tif err != nil {\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n\t\t\t\tzap.String(\"key\", conflict.Key),\n\t\t\t\tzap.Error(err))\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\n\t\t}\n\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   mergedValue,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\n\t\t}, nil\n\t}\n\n\t// Non-mergeable, fall back to LWW\n\treturn r.resolveCRDTLastWriterWins(conflict)\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\n   392 | }\n   393 | \n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\n   395 | \t// Check if value is a type that can be merged\nâ†’  396 | \tswitch v := value.(type) {\n   397 | \tcase map[string]interface{}:\n   398 | \t\treturn true\n   399 | \tcase []interface{}:\n   400 | \t\treturn true\n   401 | \tcase map[string]string:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\n   411 | \t// Implement actual CRDT merge logic based on value type\n   412 | \tswitch l := local.(type) {\n   413 | \tcase map[string]interface{}:\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n   421 | \t}\n   422 | \n   423 | \t// Cannot merge, return error\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 8,
        "affected_lines": 23,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "30-60 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    }
  ],
  "high": [
    {
      "type": "Linter limpo",
      "severity": "high",
      "location": "multiplos arquivos",
      "description": "âœ— FAIL: 13 issues crÃ­ticos, 0 warnings",
      "suggestion": "Corrija os issues FAIL primeiro, depois warnings",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": [
          {
            "tool_name": "golangci-lint",
            "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
            "diagnose_command": "golangci-lint run",
            "fix_command": "# NAO use --fix automaticamente, revise cada issue",
            "config_required": true,
            "config_template": ".golangci.yml com linters selecionados",
            "documentation": "https://golangci-lint.run/",
            "alternative_tools": null
          },
          {
            "tool_name": "staticcheck",
            "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
            "diagnose_command": "staticcheck ./...",
            "fix_command": "# Manual - staticcheck nao tem auto-fix",
            "config_required": false,
            "config_template": "",
            "documentation": "https://staticcheck.io/",
            "alternative_tools": null
          },
          {
            "tool_name": "gosec",
            "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
            "diagnose_command": "gosec ./...",
            "fix_command": "# Manual - corrija issues de seguranca",
            "config_required": false,
            "config_template": "",
            "documentation": "https://github.com/securego/gosec",
            "alternative_tools": null
          }
        ],
        "executable_steps": null,
        "estimated_time": "26m",
        "confidence": 0
      },
      "examples": [
        "ðŸ“¦ MÃ³dulos analisados: 1",
        "ðŸ“„ Linter Report v7: JSON + SARIF gerados",
        "",
        "ðŸ“Š Resumo por ferramenta (todos os mÃ³dulos):",
        "  â€¢ golangci-lint: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ govet: ð„‚ 13 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ staticcheck: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "",
        "ðŸ” Top issues prioritÃ¡rios (FAIL):",
        "  1. [govet] internal/mcp/protocol/handlers.go:344 - h.parseParams undefined (type *ListTemplatesHandler has no field or me... (govet)",
        "  2. [govet] internal/mcp/protocol/handlers.go:446 - h.parseParams undefined (type *ListProjectsHandler has no field or met... (govet)",
        "  3. [govet] tools/deployers/hybrid_deployer.go:10 - \"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud... (govet)",
        "  4. [govet] vet.exe: internal/ai/knowledge/indexer_test.go:68 - not enough arguments in call to NewIndexer (govet)",
        "  5. [govet] internal/domain/value_objects/validation_rule.go:69 - non-constant format string in call to fmt.Errorf (govet)",
        "  6. [govet] vet.exe: internal/infrastructure/compute/serverless/cloud_functions.go:14 - undefined: FunctionConfig (govet)",
        "  7. [govet] vet.exe: internal/mcp/protocol/handlers.go:344 - h.parseParams undefined (type *ListTemplatesHandler has no field or me... (govet)",
        "  8. [govet] vet.exe: internal/state/events/event_replay.go:249 - declared and not used: snapshot (govet)",
        "  9. [govet] vet.exe: internal/state/cache/cache_coherency.go:162 - cm.cache.Delete undefined (type *StateCache is pointer to interface, n... (govet)",
        "  10. [govet] vet.exe: internal/security/config/integration.go:215 - ruleCfg.Resource undefined (type PolicyRuleConfig has no field or meth... (govet)"
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": null,
      "impact_analysis": {
        "severity": "high",
        "affected_files": 13,
        "affected_lines": 13,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "26m",
        "priority": 2,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [
        "performance",
        "memory-optimization"
      ],
      "error_breakdown": {
        "govet": 13
      },
      "top_files": [
        "internal/mcp/protocol/handlers.go (2)",
        "pkg/httpserver/server_test.go (2)",
        "vet.exe: internal/security/config/integration.go (1)",
        "tools/deployers/hybrid_deployer.go (1)",
        "vet.exe: internal/ai/knowledge/indexer_test.go (1)"
      ]
    }
  ],
  "medium": null,
  "low": null,
  "total_gaps": 3,
  "score": 85,
  "auto_fixable": 0,
  "manual": 3,
  "top_priorities": [
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(generateCmd)\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\n    49 | }\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(generateCmd)\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n\tgenerateCmd.MarkFlagRequired(\"template\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\n    20 | \t\treturn nil\n    21 | \t},\n    22 | }\n    23 | \nâ†’   24 | func init() {\n    25 | \trootCmd.AddCommand(monitorCmd)\n    26 | }\n    27 | \n    28 | // SetMonitoringService sets the monitoring service\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(monitorCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 38,
          "code_snippet": "    33 | \t\tos.Exit(1)\n    34 | \t}\n    35 | }\n    36 | \n    37 | // init initializes the CLI\nâ†’   38 | func init() {\n    39 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    40 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    41 | \n    42 | \t// Add subcommand groups\n    43 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\t// ci.CICmd removido - pacote ci nÃ£o existe ainda\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/cli/analytics",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\n    16 | \t\treturn nil\n    17 | \t},\n    18 | }\n    19 | \nâ†’   20 | func init() {\n    21 | \trootCmd.AddCommand(stateCmd)\n    22 | }\n    23 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(stateCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(templateCmd)\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(templateCmd)\n\ttemplateCmd.AddCommand(templateListCmd)\n\ttemplateCmd.AddCommand(templateCreateCmd)\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\n    18 | \t},\n    19 | }\n    20 | \nâ†’   21 | func init() {\n    22 | \trootCmd.AddCommand(versionCmd)\n    23 | }\n    24 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(versionCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\n    19 | \t\treturn nil\n    20 | \t},\n    21 | }\n    22 | \nâ†’   23 | func init() {\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\n    25 | }\n    26 | \n",
          "full_function": "func init() {\n\tAnalyticsCmd.AddCommand(performanceCmd)\n}",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-fulfillment-ops/internal/mcp/protocol\ninternal\\mcp\\protocol\\handlers.go:344:4: h.parseParams undefined (type *ListTemplatesHandler has no field or method parseParams)\ninterna...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\docs\\validation\\raw\\2025-11-21-16-16-07-compilation.log",
        "",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/mcp/protocol",
        "internal\\mcp\\protocol\\handlers.go:344:4: h.parseParams undefined (type *ListTemplatesHandler has no field or method parseParams)",
        "internal\\mcp\\protocol\\handlers.go:446:4: h.parseParams undefined (type *ListProjectsHandler has no field or method parseParams)",
        "# github.com/vertikon/mcp-fulfillment-ops/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\" imported and not used",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/security/config",
        "internal\\security\\config\\integration.go:215:26: ruleCfg.Resource undefined (type PolicyRuleConfig has no field or method Resource)",
        "internal\\security\\config\\integration.go:216:26: ruleCfg.Action undefined (type PolicyRuleConfig has no field or method Action)",
        "internal\\security\\config\\integration.go:218:26: ruleCfg.Description undefined (type PolicyRuleConfig has no field or method Description)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\protocol\\handlers.go",
          "line_number": 344,
          "code_snippet": "   339 | \tvar params struct {\n   340 | \t\tStack    string `json:\"stack,omitempty\"`\n   341 | \t\tCategory string `json:\"category,omitempty\"`\n   342 | \t}\n   343 | \nâ†’  344 | \th.parseParams(request.Params, \u0026params)\n   345 | \n   346 | \ttemplates, err := h.registry.ListTemplates(registry.TemplateFilter{\n   347 | \t\tStack:    params.Stack,\n   348 | \t\tCategory: params.Category,\n   349 | \t})\n",
          "full_function": "\th.parseParams(request.Params, \u0026params)\n\n\ttemplates, err := h.registry.ListTemplates(registry.TemplateFilter{\n\t\tStack:    params.Stack,\n\t\tCategory: params.Category,\n\t})",
          "symbol_name": "",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "os",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/registry",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/validators",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\protocol\\handlers.go",
          "line_number": 446,
          "code_snippet": "   441 | \tvar params struct {\n   442 | \t\tStack  string `json:\"stack,omitempty\"`\n   443 | \t\tStatus string `json:\"status,omitempty\"`\n   444 | \t}\n   445 | \nâ†’  446 | \th.parseParams(request.Params, \u0026params)\n   447 | \n   448 | \tprojects, err := h.registry.ListProjects(registry.ProjectFilter{\n   449 | \t\tStack:  params.Stack,\n   450 | \t\tStatus: params.Status,\n   451 | \t})\n",
          "full_function": "\th.parseParams(request.Params, \u0026params)\n\n\tprojects, err := h.registry.ListProjects(registry.ProjectFilter{\n\t\tStack:  params.Stack,\n\t\tStatus: params.Status,\n\t})",
          "symbol_name": "",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "os",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/registry",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/validators",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\n     6 | \t\"os\"\n     7 | \t\"path/filepath\"\n     8 | \t\"time\"\n     9 | \nâ†’   10 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n    11 | \t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n    12 | \t\"go.uber.org/zap\"\n    13 | )\n    14 | \n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n",
          "full_function": "\t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\ntype HybridDeployer struct {\n\tdockerDeployer     *DockerDeployer\n\tkubernetesDeployer *KubernetesDeployer\n\tserverlessDeployer *ServerlessDeployer\n\tlogger             *zap.Logger\n}",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\n    10 | \t// Invoke invokes a cloud function\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\n    12 | \n    13 | \t// CreateFunction creates a cloud function\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\n    15 | \n    16 | \t// DeleteFunction deletes a cloud function\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\n    18 | }\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 215,
          "code_snippet": "   210 | \t\t\tif ruleCfg.Effect == \"deny\" {\n   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\nâ†’  215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\nâ†’  216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 218,
          "code_snippet": "   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\nâ†’  218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n   222 | \t\t\t}\n   223 | \t\t\tpolicy.Rules = append(policy.Rules, rule)\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\n   158 | \tcm.stats.InvalidationsByReason[reason]++\n   159 | \tcm.mu.Unlock()\n   160 | \n   161 | \t// Delete from cache\nâ†’  162 | \tcm.cache.Delete(key)\n   163 | \n   164 | \t// Create invalidation event\n   165 | \tevent := \u0026InvalidationEvent{\n   166 | \t\tKey:       key,\n   167 | \t\tReason:    reason,\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\n\tstart := time.Now()\n\n\tcm.mu.Lock()\n\tcm.stats.TotalInvalidations++\n\tcm.stats.InvalidationsByReason[reason]++\n\tcm.mu.Unlock()\n\n\t// Delete from cache\n\tcm.cache.Delete(key)\n\n\t// Create invalidation event\n\tevent := \u0026InvalidationEvent{\n\t\tKey:       key,\n\t\tReason:    reason,\n\t\tTimestamp: time.Now(),\n\t\tSource:    \"coherency_manager\",\n\t}\n\n\t// Send to invalidation channel\n\tselect {\n\tcase cm.invalidationCh \u003c- event:\n\tdefault:\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\n\t\t\tzap.String(\"key\", key))\n\t}\n\n\tcm.mu.Lock()\n\tcm.stats.AverageInvalidationTime = time.Since(start)\n\tlastTime := time.Now()\n\tcm.stats.LastInvalidation = \u0026lastTime\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Cache key invalidated\",\n\t\tzap.String(\"key\", key),\n\t\tzap.String(\"reason\", reason))\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\n   213 | \n   214 | // Update updates a cache entry\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\n   216 | \tcm.mu.Lock()\nâ†’  217 | \tcm.stats.TotalUpdates++\n   218 | \tcm.mu.Unlock()\n   219 | \n   220 | \t// Update cache based on strategy\n   221 | \tswitch cm.config.Strategy {\n   222 | \tcase CoherencyStrategyWriteThrough:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\n   249 | \t\tLevel:                cm.config.Level,\n   250 | \t\tIsCoherent:           true, // Simplified\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\n   254 | \t}, nil\n   255 | }\n   256 | \n   257 | // GetInvalidationStats returns invalidation statistics\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\treturn \u0026CoherencyStatus{\n\t\tStrategy:             cm.config.Strategy,\n\t\tLevel:                cm.config.Level,\n\t\tIsCoherent:           true, // Simplified\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\n   338 | \tcm.pendingInvalidations[event.Key] = event\n   339 | \tcm.mu.Unlock()\n   340 | \n   341 | \t// Process invalidation\nâ†’  342 | \tcm.cache.Delete(event.Key)\n   343 | \n   344 | \tcm.mu.Lock()\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\n   346 | \tcm.mu.Unlock()\n   347 | \n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\n\tcm.mu.Lock()\n\tcm.pendingInvalidations[event.Key] = event\n\tcm.mu.Unlock()\n\n\t// Process invalidation\n\tcm.cache.Delete(event.Key)\n\n\tcm.mu.Lock()\n\tdelete(cm.pendingInvalidations, event.Key)\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Invalidation processed\",\n\t\tzap.String(\"key\", event.Key),\n\t\tzap.String(\"reason\", event.Reason))\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\n   245 | \n   246 | // ReplayFromSnapshot replays events from a snapshot version\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n   248 | \t// Get snapshot\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n   250 | \tif err != nil {\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n   252 | \t}\n   253 | \n   254 | \t// Get events after snapshot version\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n\t// Get snapshot\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n\t}\n\n\t// Get events after snapshot version\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\n\t}\n\n\tif len(events) == 0 {\n\t\treturn \u0026ReplayProgress{\n\t\t\tTotalEvents:     0,\n\t\t\tProcessedEvents: 0,\n\t\t\tIsComplete:      true,\n\t\t}, nil\n\t}\n\n\tstartTime := time.Now()\n\tprogress := \u0026ReplayProgress{\n\t\tTotalEvents:    int64(len(events)),\n\t\tStartTime:      startTime,\n\t\tCurrentVersion: snapshotVersion + 1,\n\t}\n\n\terr = er.replaySequential(ctx, events, handler, progress)\n\tprogress.ElapsedTime = time.Since(startTime)\n\tprogress.IsComplete = true\n\n\tif err != nil {\n\t\tprogress.LastError = err.Error()\n\t\treturn progress, err\n\t}\n\n\treturn progress, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\n   286 | \n   287 | // ReplayToState replays events to rebuild state at a specific version\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\n   289 | \t// Get all events up to target version\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\n   291 | \tif err != nil {\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\n   293 | \t}\n   294 | \n   295 | \t// Replay events\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\n   136 | \t\t// Return copy\n   137 | \t\tcopy := *versionInfo\n   138 | \t\tif versionInfo.VersionHistory != nil {\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n   141 | \t\t}\n   142 | \t\treturn \u0026copy, nil\n   143 | \t}\n   144 | \n   145 | \t// Load from event store\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\n\tev.mu.RLock()\n\tversionInfo, exists := ev.versions[aggregateID]\n\tev.mu.RUnlock()\n\n\tif exists {\n\t\t// Return copy\n\t\tcopy := *versionInfo\n\t\tif versionInfo.VersionHistory != nil {\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n\t\t}\n\t\treturn \u0026copy, nil\n\t}\n\n\t// Load from event store\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t}\n\n\tversionInfo = \u0026VersionInfo{\n\t\tAggregateID:    aggregateID,\n\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\tCurrentVersion: aggregateInfo.Version,\n\t\tMetadata:       make(map[string]interface{}),\n\t}\n\n\tif ev.config.EnableHistory {\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t}\n\n\tev.mu.Lock()\n\tev.versions[aggregateID] = versionInfo\n\tev.mu.Unlock()\n\n\treturn versionInfo, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n   213 | \t\t}\n   214 | \n   215 | \t\t// Resolve conflict\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n   217 | \t\tif err != nil {\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n   219 | \t\t}\n   220 | \n   221 | \t\tnewVersion = resolvedVersion\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\n\tev.mu.Lock()\n\tdefer ev.mu.Unlock()\n\n\tversionInfo, exists := ev.versions[aggregateID]\n\tif !exists {\n\t\t// Load from store\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t\t}\n\n\t\tversionInfo = \u0026VersionInfo{\n\t\t\tAggregateID:    aggregateID,\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\t\tCurrentVersion: aggregateInfo.Version,\n\t\t\tMetadata:       make(map[string]interface{}),\n\t\t}\n\n\t\tif ev.config.EnableHistory {\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t\t}\n\n\t\tev.versions[aggregateID] = versionInfo\n\t}\n\n\t// Increment version\n\tnewVersion := versionInfo.CurrentVersion + 1\n\n\t// Validate version continuity\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\n\t\tconflict := \u0026VersionConflict{\n\t\t\tAggregateID:     aggregateID,\n\t\t\tExpectedVersion: newVersion,\n\t\t\tActualVersion:   event.Version,\n\t\t\tConflictTime:    time.Now(),\n\t\t}\n\n\t\tev.stats.TotalConflicts++\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\n\n\t\tif ev.config.ConflictResolution == \"reject\" {\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n\t\t}\n\n\t\t// Resolve conflict\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n\t\t}\n\n\t\tnewVersion = resolvedVersion\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\n\t\tev.stats.ResolvedConflicts++\n\t}\n\n\t// Update version info\n\tversionInfo.CurrentVersion = newVersion\n\tversionInfo.LastEventID = event.ID\n\tversionInfo.LastEventTime = event.Timestamp\n\n\t// Add to history\n\tif ev.config.EnableHistory {\n\t\tentry := VersionHistoryEntry{\n\t\t\tVersion:   newVersion,\n\t\t\tEventID:   event.ID,\n\t\t\tTimestamp: event.Timestamp,\n\t\t\tEventType: event.Type,\n\t\t}\n\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\n\n\t\t// Trim history if needed\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\n\t\t}\n\t}\n\n\t// Update statistics\n\tev.stats.TotalVersions++\n\tev.stats.VersionDistribution[newVersion]++\n\n\tev.logger.Debug(\"Version incremented\",\n\t\tzap.String(\"aggregate_id\", aggregateID),\n\t\tzap.Int64(\"version\", newVersion))\n\n\treturn newVersion, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\n   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n   242 | \tdefault:\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\n   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n   257 | \n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n   279 | \t// For simple values, use last-write-wins\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\n   281 | \n   282 | \t// Check if values are mergeable\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n   285 | \t\tif err != nil {\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\n   288 | \t\t\t\tzap.Error(err))\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n\t// For simple values, use last-write-wins\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\n\n\t// Check if values are mergeable\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n\t\tif err != nil {\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n\t\t\t\tzap.String(\"key\", conflict.Key),\n\t\t\t\tzap.Error(err))\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\n\t\t}\n\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   mergedValue,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\n\t\t}, nil\n\t}\n\n\t// Non-mergeable, fall back to LWW\n\treturn r.resolveCRDTLastWriterWins(conflict)\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\n   392 | }\n   393 | \n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\n   395 | \t// Check if value is a type that can be merged\nâ†’  396 | \tswitch v := value.(type) {\n   397 | \tcase map[string]interface{}:\n   398 | \t\treturn true\n   399 | \tcase []interface{}:\n   400 | \t\treturn true\n   401 | \tcase map[string]string:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\n   411 | \t// Implement actual CRDT merge logic based on value type\n   412 | \tswitch l := local.(type) {\n   413 | \tcase map[string]interface{}:\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n   421 | \t}\n   422 | \n   423 | \t// Cannot merge, return error\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 8,
        "affected_lines": 23,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "30-60 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Linter limpo",
      "severity": "high",
      "location": "multiplos arquivos",
      "description": "âœ— FAIL: 13 issues crÃ­ticos, 0 warnings",
      "suggestion": "Corrija os issues FAIL primeiro, depois warnings",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": [
          {
            "tool_name": "golangci-lint",
            "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
            "diagnose_command": "golangci-lint run",
            "fix_command": "# NAO use --fix automaticamente, revise cada issue",
            "config_required": true,
            "config_template": ".golangci.yml com linters selecionados",
            "documentation": "https://golangci-lint.run/",
            "alternative_tools": null
          },
          {
            "tool_name": "staticcheck",
            "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
            "diagnose_command": "staticcheck ./...",
            "fix_command": "# Manual - staticcheck nao tem auto-fix",
            "config_required": false,
            "config_template": "",
            "documentation": "https://staticcheck.io/",
            "alternative_tools": null
          },
          {
            "tool_name": "gosec",
            "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
            "diagnose_command": "gosec ./...",
            "fix_command": "# Manual - corrija issues de seguranca",
            "config_required": false,
            "config_template": "",
            "documentation": "https://github.com/securego/gosec",
            "alternative_tools": null
          }
        ],
        "executable_steps": null,
        "estimated_time": "26m",
        "confidence": 0
      },
      "examples": [
        "ðŸ“¦ MÃ³dulos analisados: 1",
        "ðŸ“„ Linter Report v7: JSON + SARIF gerados",
        "",
        "ðŸ“Š Resumo por ferramenta (todos os mÃ³dulos):",
        "  â€¢ golangci-lint: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ govet: ð„‚ 13 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ staticcheck: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "",
        "ðŸ” Top issues prioritÃ¡rios (FAIL):",
        "  1. [govet] internal/mcp/protocol/handlers.go:344 - h.parseParams undefined (type *ListTemplatesHandler has no field or me... (govet)",
        "  2. [govet] internal/mcp/protocol/handlers.go:446 - h.parseParams undefined (type *ListProjectsHandler has no field or met... (govet)",
        "  3. [govet] tools/deployers/hybrid_deployer.go:10 - \"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud... (govet)",
        "  4. [govet] vet.exe: internal/ai/knowledge/indexer_test.go:68 - not enough arguments in call to NewIndexer (govet)",
        "  5. [govet] internal/domain/value_objects/validation_rule.go:69 - non-constant format string in call to fmt.Errorf (govet)",
        "  6. [govet] vet.exe: internal/infrastructure/compute/serverless/cloud_functions.go:14 - undefined: FunctionConfig (govet)",
        "  7. [govet] vet.exe: internal/mcp/protocol/handlers.go:344 - h.parseParams undefined (type *ListTemplatesHandler has no field or me... (govet)",
        "  8. [govet] vet.exe: internal/state/events/event_replay.go:249 - declared and not used: snapshot (govet)",
        "  9. [govet] vet.exe: internal/state/cache/cache_coherency.go:162 - cm.cache.Delete undefined (type *StateCache is pointer to interface, n... (govet)",
        "  10. [govet] vet.exe: internal/security/config/integration.go:215 - ruleCfg.Resource undefined (type PolicyRuleConfig has no field or meth... (govet)"
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": null,
      "impact_analysis": {
        "severity": "high",
        "affected_files": 13,
        "affected_lines": 13,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "26m",
        "priority": 2,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [
        "performance",
        "memory-optimization"
      ],
      "error_breakdown": {
        "govet": 13
      },
      "top_files": [
        "internal/mcp/protocol/handlers.go (2)",
        "pkg/httpserver/server_test.go (2)",
        "vet.exe: internal/security/config/integration.go (1)",
        "tools/deployers/hybrid_deployer.go (1)",
        "vet.exe: internal/ai/knowledge/indexer_test.go (1)"
      ]
    }
  ],
  "quick_wins": null,
  "blockers": [
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(generateCmd)\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\n    49 | }\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(generateCmd)\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n\tgenerateCmd.MarkFlagRequired(\"template\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\n    20 | \t\treturn nil\n    21 | \t},\n    22 | }\n    23 | \nâ†’   24 | func init() {\n    25 | \trootCmd.AddCommand(monitorCmd)\n    26 | }\n    27 | \n    28 | // SetMonitoringService sets the monitoring service\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(monitorCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 38,
          "code_snippet": "    33 | \t\tos.Exit(1)\n    34 | \t}\n    35 | }\n    36 | \n    37 | // init initializes the CLI\nâ†’   38 | func init() {\n    39 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    40 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    41 | \n    42 | \t// Add subcommand groups\n    43 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\t// ci.CICmd removido - pacote ci nÃ£o existe ainda\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/cli/analytics",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\n    16 | \t\treturn nil\n    17 | \t},\n    18 | }\n    19 | \nâ†’   20 | func init() {\n    21 | \trootCmd.AddCommand(stateCmd)\n    22 | }\n    23 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(stateCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(templateCmd)\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(templateCmd)\n\ttemplateCmd.AddCommand(templateListCmd)\n\ttemplateCmd.AddCommand(templateCreateCmd)\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\n    18 | \t},\n    19 | }\n    20 | \nâ†’   21 | func init() {\n    22 | \trootCmd.AddCommand(versionCmd)\n    23 | }\n    24 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(versionCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\n    19 | \t\treturn nil\n    20 | \t},\n    21 | }\n    22 | \nâ†’   23 | func init() {\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\n    25 | }\n    26 | \n",
          "full_function": "func init() {\n\tAnalyticsCmd.AddCommand(performanceCmd)\n}",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-fulfillment-ops/internal/mcp/protocol\ninternal\\mcp\\protocol\\handlers.go:344:4: h.parseParams undefined (type *ListTemplatesHandler has no field or method parseParams)\ninterna...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\docs\\validation\\raw\\2025-11-21-16-16-07-compilation.log",
        "",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/mcp/protocol",
        "internal\\mcp\\protocol\\handlers.go:344:4: h.parseParams undefined (type *ListTemplatesHandler has no field or method parseParams)",
        "internal\\mcp\\protocol\\handlers.go:446:4: h.parseParams undefined (type *ListProjectsHandler has no field or method parseParams)",
        "# github.com/vertikon/mcp-fulfillment-ops/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\" imported and not used",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/security/config",
        "internal\\security\\config\\integration.go:215:26: ruleCfg.Resource undefined (type PolicyRuleConfig has no field or method Resource)",
        "internal\\security\\config\\integration.go:216:26: ruleCfg.Action undefined (type PolicyRuleConfig has no field or method Action)",
        "internal\\security\\config\\integration.go:218:26: ruleCfg.Description undefined (type PolicyRuleConfig has no field or method Description)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\protocol\\handlers.go",
          "line_number": 344,
          "code_snippet": "   339 | \tvar params struct {\n   340 | \t\tStack    string `json:\"stack,omitempty\"`\n   341 | \t\tCategory string `json:\"category,omitempty\"`\n   342 | \t}\n   343 | \nâ†’  344 | \th.parseParams(request.Params, \u0026params)\n   345 | \n   346 | \ttemplates, err := h.registry.ListTemplates(registry.TemplateFilter{\n   347 | \t\tStack:    params.Stack,\n   348 | \t\tCategory: params.Category,\n   349 | \t})\n",
          "full_function": "\th.parseParams(request.Params, \u0026params)\n\n\ttemplates, err := h.registry.ListTemplates(registry.TemplateFilter{\n\t\tStack:    params.Stack,\n\t\tCategory: params.Category,\n\t})",
          "symbol_name": "",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "os",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/registry",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/validators",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\protocol\\handlers.go",
          "line_number": 446,
          "code_snippet": "   441 | \tvar params struct {\n   442 | \t\tStack  string `json:\"stack,omitempty\"`\n   443 | \t\tStatus string `json:\"status,omitempty\"`\n   444 | \t}\n   445 | \nâ†’  446 | \th.parseParams(request.Params, \u0026params)\n   447 | \n   448 | \tprojects, err := h.registry.ListProjects(registry.ProjectFilter{\n   449 | \t\tStack:  params.Stack,\n   450 | \t\tStatus: params.Status,\n   451 | \t})\n",
          "full_function": "\th.parseParams(request.Params, \u0026params)\n\n\tprojects, err := h.registry.ListProjects(registry.ProjectFilter{\n\t\tStack:  params.Stack,\n\t\tStatus: params.Status,\n\t})",
          "symbol_name": "",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "os",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/registry",
            "github.com/vertikon/mcp-fulfillment-ops/internal/mcp/validators",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\n     6 | \t\"os\"\n     7 | \t\"path/filepath\"\n     8 | \t\"time\"\n     9 | \nâ†’   10 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n    11 | \t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n    12 | \t\"go.uber.org/zap\"\n    13 | )\n    14 | \n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n",
          "full_function": "\t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\ntype HybridDeployer struct {\n\tdockerDeployer     *DockerDeployer\n\tkubernetesDeployer *KubernetesDeployer\n\tserverlessDeployer *ServerlessDeployer\n\tlogger             *zap.Logger\n}",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\n    10 | \t// Invoke invokes a cloud function\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\n    12 | \n    13 | \t// CreateFunction creates a cloud function\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\n    15 | \n    16 | \t// DeleteFunction deletes a cloud function\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\n    18 | }\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 215,
          "code_snippet": "   210 | \t\t\tif ruleCfg.Effect == \"deny\" {\n   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\nâ†’  215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\nâ†’  216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 218,
          "code_snippet": "   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\nâ†’  218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n   222 | \t\t\t}\n   223 | \t\t\tpolicy.Rules = append(policy.Rules, rule)\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\n   158 | \tcm.stats.InvalidationsByReason[reason]++\n   159 | \tcm.mu.Unlock()\n   160 | \n   161 | \t// Delete from cache\nâ†’  162 | \tcm.cache.Delete(key)\n   163 | \n   164 | \t// Create invalidation event\n   165 | \tevent := \u0026InvalidationEvent{\n   166 | \t\tKey:       key,\n   167 | \t\tReason:    reason,\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\n\tstart := time.Now()\n\n\tcm.mu.Lock()\n\tcm.stats.TotalInvalidations++\n\tcm.stats.InvalidationsByReason[reason]++\n\tcm.mu.Unlock()\n\n\t// Delete from cache\n\tcm.cache.Delete(key)\n\n\t// Create invalidation event\n\tevent := \u0026InvalidationEvent{\n\t\tKey:       key,\n\t\tReason:    reason,\n\t\tTimestamp: time.Now(),\n\t\tSource:    \"coherency_manager\",\n\t}\n\n\t// Send to invalidation channel\n\tselect {\n\tcase cm.invalidationCh \u003c- event:\n\tdefault:\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\n\t\t\tzap.String(\"key\", key))\n\t}\n\n\tcm.mu.Lock()\n\tcm.stats.AverageInvalidationTime = time.Since(start)\n\tlastTime := time.Now()\n\tcm.stats.LastInvalidation = \u0026lastTime\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Cache key invalidated\",\n\t\tzap.String(\"key\", key),\n\t\tzap.String(\"reason\", reason))\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\n   213 | \n   214 | // Update updates a cache entry\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\n   216 | \tcm.mu.Lock()\nâ†’  217 | \tcm.stats.TotalUpdates++\n   218 | \tcm.mu.Unlock()\n   219 | \n   220 | \t// Update cache based on strategy\n   221 | \tswitch cm.config.Strategy {\n   222 | \tcase CoherencyStrategyWriteThrough:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\n   249 | \t\tLevel:                cm.config.Level,\n   250 | \t\tIsCoherent:           true, // Simplified\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\n   254 | \t}, nil\n   255 | }\n   256 | \n   257 | // GetInvalidationStats returns invalidation statistics\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\treturn \u0026CoherencyStatus{\n\t\tStrategy:             cm.config.Strategy,\n\t\tLevel:                cm.config.Level,\n\t\tIsCoherent:           true, // Simplified\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\n   338 | \tcm.pendingInvalidations[event.Key] = event\n   339 | \tcm.mu.Unlock()\n   340 | \n   341 | \t// Process invalidation\nâ†’  342 | \tcm.cache.Delete(event.Key)\n   343 | \n   344 | \tcm.mu.Lock()\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\n   346 | \tcm.mu.Unlock()\n   347 | \n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\n\tcm.mu.Lock()\n\tcm.pendingInvalidations[event.Key] = event\n\tcm.mu.Unlock()\n\n\t// Process invalidation\n\tcm.cache.Delete(event.Key)\n\n\tcm.mu.Lock()\n\tdelete(cm.pendingInvalidations, event.Key)\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Invalidation processed\",\n\t\tzap.String(\"key\", event.Key),\n\t\tzap.String(\"reason\", event.Reason))\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\n   245 | \n   246 | // ReplayFromSnapshot replays events from a snapshot version\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n   248 | \t// Get snapshot\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n   250 | \tif err != nil {\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n   252 | \t}\n   253 | \n   254 | \t// Get events after snapshot version\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n\t// Get snapshot\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n\t}\n\n\t// Get events after snapshot version\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\n\t}\n\n\tif len(events) == 0 {\n\t\treturn \u0026ReplayProgress{\n\t\t\tTotalEvents:     0,\n\t\t\tProcessedEvents: 0,\n\t\t\tIsComplete:      true,\n\t\t}, nil\n\t}\n\n\tstartTime := time.Now()\n\tprogress := \u0026ReplayProgress{\n\t\tTotalEvents:    int64(len(events)),\n\t\tStartTime:      startTime,\n\t\tCurrentVersion: snapshotVersion + 1,\n\t}\n\n\terr = er.replaySequential(ctx, events, handler, progress)\n\tprogress.ElapsedTime = time.Since(startTime)\n\tprogress.IsComplete = true\n\n\tif err != nil {\n\t\tprogress.LastError = err.Error()\n\t\treturn progress, err\n\t}\n\n\treturn progress, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\n   286 | \n   287 | // ReplayToState replays events to rebuild state at a specific version\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\n   289 | \t// Get all events up to target version\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\n   291 | \tif err != nil {\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\n   293 | \t}\n   294 | \n   295 | \t// Replay events\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\n   136 | \t\t// Return copy\n   137 | \t\tcopy := *versionInfo\n   138 | \t\tif versionInfo.VersionHistory != nil {\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n   141 | \t\t}\n   142 | \t\treturn \u0026copy, nil\n   143 | \t}\n   144 | \n   145 | \t// Load from event store\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\n\tev.mu.RLock()\n\tversionInfo, exists := ev.versions[aggregateID]\n\tev.mu.RUnlock()\n\n\tif exists {\n\t\t// Return copy\n\t\tcopy := *versionInfo\n\t\tif versionInfo.VersionHistory != nil {\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n\t\t}\n\t\treturn \u0026copy, nil\n\t}\n\n\t// Load from event store\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t}\n\n\tversionInfo = \u0026VersionInfo{\n\t\tAggregateID:    aggregateID,\n\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\tCurrentVersion: aggregateInfo.Version,\n\t\tMetadata:       make(map[string]interface{}),\n\t}\n\n\tif ev.config.EnableHistory {\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t}\n\n\tev.mu.Lock()\n\tev.versions[aggregateID] = versionInfo\n\tev.mu.Unlock()\n\n\treturn versionInfo, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n   213 | \t\t}\n   214 | \n   215 | \t\t// Resolve conflict\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n   217 | \t\tif err != nil {\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n   219 | \t\t}\n   220 | \n   221 | \t\tnewVersion = resolvedVersion\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\n\tev.mu.Lock()\n\tdefer ev.mu.Unlock()\n\n\tversionInfo, exists := ev.versions[aggregateID]\n\tif !exists {\n\t\t// Load from store\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t\t}\n\n\t\tversionInfo = \u0026VersionInfo{\n\t\t\tAggregateID:    aggregateID,\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\t\tCurrentVersion: aggregateInfo.Version,\n\t\t\tMetadata:       make(map[string]interface{}),\n\t\t}\n\n\t\tif ev.config.EnableHistory {\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t\t}\n\n\t\tev.versions[aggregateID] = versionInfo\n\t}\n\n\t// Increment version\n\tnewVersion := versionInfo.CurrentVersion + 1\n\n\t// Validate version continuity\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\n\t\tconflict := \u0026VersionConflict{\n\t\t\tAggregateID:     aggregateID,\n\t\t\tExpectedVersion: newVersion,\n\t\t\tActualVersion:   event.Version,\n\t\t\tConflictTime:    time.Now(),\n\t\t}\n\n\t\tev.stats.TotalConflicts++\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\n\n\t\tif ev.config.ConflictResolution == \"reject\" {\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n\t\t}\n\n\t\t// Resolve conflict\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n\t\t}\n\n\t\tnewVersion = resolvedVersion\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\n\t\tev.stats.ResolvedConflicts++\n\t}\n\n\t// Update version info\n\tversionInfo.CurrentVersion = newVersion\n\tversionInfo.LastEventID = event.ID\n\tversionInfo.LastEventTime = event.Timestamp\n\n\t// Add to history\n\tif ev.config.EnableHistory {\n\t\tentry := VersionHistoryEntry{\n\t\t\tVersion:   newVersion,\n\t\t\tEventID:   event.ID,\n\t\t\tTimestamp: event.Timestamp,\n\t\t\tEventType: event.Type,\n\t\t}\n\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\n\n\t\t// Trim history if needed\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\n\t\t}\n\t}\n\n\t// Update statistics\n\tev.stats.TotalVersions++\n\tev.stats.VersionDistribution[newVersion]++\n\n\tev.logger.Debug(\"Version incremented\",\n\t\tzap.String(\"aggregate_id\", aggregateID),\n\t\tzap.Int64(\"version\", newVersion))\n\n\treturn newVersion, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\n   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n   242 | \tdefault:\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\n   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n   257 | \n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n   279 | \t// For simple values, use last-write-wins\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\n   281 | \n   282 | \t// Check if values are mergeable\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n   285 | \t\tif err != nil {\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\n   288 | \t\t\t\tzap.Error(err))\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n\t// For simple values, use last-write-wins\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\n\n\t// Check if values are mergeable\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n\t\tif err != nil {\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n\t\t\t\tzap.String(\"key\", conflict.Key),\n\t\t\t\tzap.Error(err))\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\n\t\t}\n\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   mergedValue,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\n\t\t}, nil\n\t}\n\n\t// Non-mergeable, fall back to LWW\n\treturn r.resolveCRDTLastWriterWins(conflict)\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\n   392 | }\n   393 | \n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\n   395 | \t// Check if value is a type that can be merged\nâ†’  396 | \tswitch v := value.(type) {\n   397 | \tcase map[string]interface{}:\n   398 | \t\treturn true\n   399 | \tcase []interface{}:\n   400 | \t\treturn true\n   401 | \tcase map[string]string:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\n   411 | \t// Implement actual CRDT merge logic based on value type\n   412 | \tswitch l := local.(type) {\n   413 | \tcase map[string]interface{}:\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n   421 | \t}\n   422 | \n   423 | \t// Cannot merge, return error\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 8,
        "affected_lines": 23,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "30-60 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    }
  ],
  "technical_debt": null,
  "recommended_tools": [
    {
      "tool_name": "golangci-lint",
      "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
      "diagnose_command": "golangci-lint run",
      "fix_command": "# NAO use --fix automaticamente, revise cada issue",
      "config_required": true,
      "config_template": ".golangci.yml com linters selecionados",
      "documentation": "https://golangci-lint.run/",
      "alternative_tools": null
    },
    {
      "tool_name": "staticcheck",
      "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
      "diagnose_command": "staticcheck ./...",
      "fix_command": "# Manual - staticcheck nao tem auto-fix",
      "config_required": false,
      "config_template": "",
      "documentation": "https://staticcheck.io/",
      "alternative_tools": null
    },
    {
      "tool_name": "gosec",
      "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
      "diagnose_command": "gosec ./...",
      "fix_command": "# Manual - corrija issues de seguranca",
      "config_required": false,
      "config_template": "",
      "documentation": "https://github.com/securego/gosec",
      "alternative_tools": null
    }
  ],
  "next_steps": [
    "ðŸ”´ URGENTE: Resolver 2 bloqueador(es)"
  ],
  "estimated_effort": "1h30m"
}