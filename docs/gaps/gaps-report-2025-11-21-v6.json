{
  "project_name": "mcp-fulfillment-ops",
  "project_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops",
  "timestamp": "2025-11-21 16:09:16",
  "validator_version": "9.4",
  "critical": [
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(generateCmd)\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\n    49 | }\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(generateCmd)\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n\tgenerateCmd.MarkFlagRequired(\"template\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\n    20 | \t\treturn nil\n    21 | \t},\n    22 | }\n    23 | \nâ†’   24 | func init() {\n    25 | \trootCmd.AddCommand(monitorCmd)\n    26 | }\n    27 | \n    28 | // SetMonitoringService sets the monitoring service\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(monitorCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 37,
          "code_snippet": "    32 | \t\tos.Exit(1)\n    33 | \t}\n    34 | }\n    35 | \n    36 | // init initializes the CLI\nâ†’   37 | func init() {\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\n    16 | \t\treturn nil\n    17 | \t},\n    18 | }\n    19 | \nâ†’   20 | func init() {\n    21 | \trootCmd.AddCommand(stateCmd)\n    22 | }\n    23 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(stateCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(templateCmd)\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(templateCmd)\n\ttemplateCmd.AddCommand(templateListCmd)\n\ttemplateCmd.AddCommand(templateCreateCmd)\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\n    18 | \t},\n    19 | }\n    20 | \nâ†’   21 | func init() {\n    22 | \trootCmd.AddCommand(versionCmd)\n    23 | }\n    24 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(versionCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\n    19 | \t\treturn nil\n    20 | \t},\n    21 | }\n    22 | \nâ†’   23 | func init() {\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\n    25 | }\n    26 | \n",
          "full_function": "func init() {\n\tAnalyticsCmd.AddCommand(performanceCmd)\n}",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators\ninternal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)\ninternal\\...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\docs\\validation\\raw\\2025-11-21-16-06-19-compilation.log",
        "",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
        "internal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:319:50: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:323:54: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:334:75: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:350:39: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\tinygo_generator.go:324:3: cannot use \"project\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:324:14: cannot use req.Name (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:3: cannot use \"language\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:15: cannot use g.language (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: cannot use \"features\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: too many errors",
        "# github.com/vertikon/mcp-fulfillment-ops/cmd/fulfillment-ops",
        "cmd\\fulfillment-ops\\main.go:13:2: \"github.com/gin-gonic/gin\" imported and not used",
        "cmd\\fulfillment-ops\\main.go:16:2: \"github.com/nats-io/nats.go/jetstream\" imported and not used",
        "cmd\\fulfillment-ops\\main.go:89:50: cannot use js (variable of interface type \"github.com/nats-io/nats.go\".JetStreamContext) as jetstream.JetStream value in argument to natsAdapter.NewEventPublisher: \"github.com/nats-io/nats.go\".JetStreamContext does not implement jetstream.JetStream (wrong type for method AccountInfo)",
        "\t\thave AccountInfo(...\"github.com/nats-io/nats.go\".JSOpt) (*\"github.com/nats-io/nats.go\".AccountInfo, error)",
        "\t\twant AccountInfo(context.Context) (*jetstream.AccountInfo, error)",
        "cmd\\fulfillment-ops\\main.go:100:53: cannot use js (variable of interface type \"github.com/nats-io/nats.go\".JetStreamContext) as jetstream.JetStream value in argument to natsAdapter.NewFulfillmentSubscriber: \"github.com/nats-io/nats.go\".JetStreamContext does not implement jetstream.JetStream (wrong type for method AccountInfo)",
        "\t\thave AccountInfo(...\"github.com/nats-io/nats.go\".JSOpt) (*\"github.com/nats-io/nats.go\".AccountInfo, error)",
        "\t\twant AccountInfo(context.Context) (*jetstream.AccountInfo, error)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/cli",
        "internal\\interfaces\\cli\\root.go:42:21: undefined: analytics",
        "internal\\interfaces\\cli\\root.go:43:21: undefined: ci",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/security/config",
        "internal\\security\\config\\integration.go:215:26: ruleCfg.Resource undefined (type PolicyRuleConfig has no field or method Resource)",
        "internal\\security\\config\\integration.go:216:26: ruleCfg.Action undefined (type PolicyRuleConfig has no field or method Action)",
        "internal\\security\\config\\integration.go:218:26: ruleCfg.Description undefined (type PolicyRuleConfig has no field or method Description)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        "# github.com/vertikon/mcp-fulfillment-ops/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\" imported and not used",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 317,
          "code_snippet": "   312 | \tif req.Path == \"\" {\n   313 | \t\treturn fmt.Errorf(\"output path is required\")\n   314 | \t}\n   315 | \n   316 | \t// Check if stack is supported\nâ†’  317 | \t_, exists := f.generators[req.Stack]\n   318 | \tif !exists {\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 319,
          "code_snippet": "   314 | \t}\n   315 | \n   316 | \t// Check if stack is supported\n   317 | \t_, exists := f.generators[req.Stack]\n   318 | \tif !exists {\nâ†’  319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\n   323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n   324 | \t\t// Validate features\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 323,
          "code_snippet": "   318 | \tif !exists {\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\nâ†’  323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n   324 | \t\t// Validate features\n   325 | \t\tfor _, feature := range req.Features {\n   326 | \t\t\tvalidFeature := false\n   327 | \t\t\tfor _, validFeat := range stackConfig.Features {\n   328 | \t\t\t\tif feature == validFeat {\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 334,
          "code_snippet": "   329 | \t\t\t\t\tvalidFeature = true\n   330 | \t\t\t\t\tbreak\n   331 | \t\t\t\t}\n   332 | \t\t\t}\n   333 | \t\t\tif !validFeature {\nâ†’  334 | \t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n   335 | \t\t\t}\n   336 | \t\t}\n   337 | \t}\n   338 | \n   339 | \treturn nil\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 350,
          "code_snippet": "   345 | \tif err := f.ValidateRequest(req); err != nil {\n   346 | \t\treturn nil, err\n   347 | \t}\n   348 | \n   349 | \t// Get generator\nâ†’  350 | \tgenerator, err := f.GetGenerator(req.Stack)\n   351 | \tif err != nil {\n   352 | \t\treturn nil, err\n   353 | \t}\n   354 | \n   355 | \t// Generate project\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\n   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\nâ†’  324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\n   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\nâ†’  324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\nâ†’  325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\nâ†’  325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\nâ†’  326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n   331 | // Validate validates wasm generator\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\nâ†’  326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n   331 | // Validate validates wasm generator\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 13,
          "code_snippet": "     8 | \t\"os\"\n     9 | \t\"os/signal\"\n    10 | \t\"syscall\"\n    11 | \t\"time\"\n    12 | \nâ†’   13 | \t\"github.com/gin-gonic/gin\"\n    14 | \t_ \"github.com/lib/pq\"\n    15 | \t\"github.com/nats-io/nats.go\"\n    16 | \t\"github.com/nats-io/nats.go/jetstream\"\n    17 | \t\"go.uber.org/zap\"\n    18 | \n",
          "full_function": "\t\"github.com/gin-gonic/gin\"\n\t_ \"github.com/lib/pq\"\n\t\"github.com/nats-io/nats.go\"\n\t\"github.com/nats-io/nats.go/jetstream\"\n\t\"go.uber.org/zap\"\n\n\tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n\tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/app\"\n\thttpHandler \"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http\"\n)\n\nfunc main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 16,
          "code_snippet": "    11 | \t\"time\"\n    12 | \n    13 | \t\"github.com/gin-gonic/gin\"\n    14 | \t_ \"github.com/lib/pq\"\n    15 | \t\"github.com/nats-io/nats.go\"\nâ†’   16 | \t\"github.com/nats-io/nats.go/jetstream\"\n    17 | \t\"go.uber.org/zap\"\n    18 | \n    19 | \tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n    20 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n    21 | \tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n",
          "full_function": "\t\"github.com/nats-io/nats.go/jetstream\"\n\t\"go.uber.org/zap\"\n\n\tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n\tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/app\"\n\thttpHandler \"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http\"\n)\n\nfunc main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 89,
          "code_snippet": "    84 | \tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n    85 | \tappLogger := app.NewZapLoggerAdapter(logger)\n    86 | \n    87 | \t// Criar adapters\n    88 | \tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\nâ†’   89 | \teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n    90 | \n    91 | \t// Criar casos de uso\n    92 | \treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    93 | \tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    94 | \tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n",
          "full_function": "func main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 100,
          "code_snippet": "    95 | \tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    96 | \topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n    97 | \tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    98 | \n    99 | \t// Iniciar subscriber NATS para eventos OMS\nâ†’  100 | \tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n   101 | \tctx, cancel := context.WithCancel(context.Background())\n   102 | \tdefer cancel()\n   103 | \n   104 | \tif err := subscriber.Start(ctx); err != nil {\n   105 | \t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n",
          "full_function": "func main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\n    10 | \t// Invoke invokes a cloud function\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\n    12 | \n    13 | \t// CreateFunction creates a cloud function\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\n    15 | \n    16 | \t// DeleteFunction deletes a cloud function\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\n    18 | }\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 42,
          "code_snippet": "    37 | func init() {\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\nâ†’   42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n    43 | \trootCmd.AddCommand(ci.CICmd)\n    44 | }\n    45 | \n    46 | // GetRootCmd returns the root command (for testing)\n    47 | func GetRootCmd() *cobra.Command {\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 43,
          "code_snippet": "    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\nâ†’   43 | \trootCmd.AddCommand(ci.CICmd)\n    44 | }\n    45 | \n    46 | // GetRootCmd returns the root command (for testing)\n    47 | func GetRootCmd() *cobra.Command {\n    48 | \treturn rootCmd\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 215,
          "code_snippet": "   210 | \t\t\tif ruleCfg.Effect == \"deny\" {\n   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\nâ†’  215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\nâ†’  216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 218,
          "code_snippet": "   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\nâ†’  218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n   222 | \t\t\t}\n   223 | \t\t\tpolicy.Rules = append(policy.Rules, rule)\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\n   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n   242 | \tdefault:\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\n   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n   257 | \n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n   279 | \t// For simple values, use last-write-wins\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\n   281 | \n   282 | \t// Check if values are mergeable\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n   285 | \t\tif err != nil {\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\n   288 | \t\t\t\tzap.Error(err))\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n\t// For simple values, use last-write-wins\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\n\n\t// Check if values are mergeable\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n\t\tif err != nil {\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n\t\t\t\tzap.String(\"key\", conflict.Key),\n\t\t\t\tzap.Error(err))\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\n\t\t}\n\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   mergedValue,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\n\t\t}, nil\n\t}\n\n\t// Non-mergeable, fall back to LWW\n\treturn r.resolveCRDTLastWriterWins(conflict)\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\n   392 | }\n   393 | \n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\n   395 | \t// Check if value is a type that can be merged\nâ†’  396 | \tswitch v := value.(type) {\n   397 | \tcase map[string]interface{}:\n   398 | \t\treturn true\n   399 | \tcase []interface{}:\n   400 | \t\treturn true\n   401 | \tcase map[string]string:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\n   411 | \t// Implement actual CRDT merge logic based on value type\n   412 | \tswitch l := local.(type) {\n   413 | \tcase map[string]interface{}:\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n   421 | \t}\n   422 | \n   423 | \t// Cannot merge, return error\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\n   158 | \tcm.stats.InvalidationsByReason[reason]++\n   159 | \tcm.mu.Unlock()\n   160 | \n   161 | \t// Delete from cache\nâ†’  162 | \tcm.cache.Delete(key)\n   163 | \n   164 | \t// Create invalidation event\n   165 | \tevent := \u0026InvalidationEvent{\n   166 | \t\tKey:       key,\n   167 | \t\tReason:    reason,\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\n\tstart := time.Now()\n\n\tcm.mu.Lock()\n\tcm.stats.TotalInvalidations++\n\tcm.stats.InvalidationsByReason[reason]++\n\tcm.mu.Unlock()\n\n\t// Delete from cache\n\tcm.cache.Delete(key)\n\n\t// Create invalidation event\n\tevent := \u0026InvalidationEvent{\n\t\tKey:       key,\n\t\tReason:    reason,\n\t\tTimestamp: time.Now(),\n\t\tSource:    \"coherency_manager\",\n\t}\n\n\t// Send to invalidation channel\n\tselect {\n\tcase cm.invalidationCh \u003c- event:\n\tdefault:\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\n\t\t\tzap.String(\"key\", key))\n\t}\n\n\tcm.mu.Lock()\n\tcm.stats.AverageInvalidationTime = time.Since(start)\n\tlastTime := time.Now()\n\tcm.stats.LastInvalidation = \u0026lastTime\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Cache key invalidated\",\n\t\tzap.String(\"key\", key),\n\t\tzap.String(\"reason\", reason))\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\n   213 | \n   214 | // Update updates a cache entry\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\n   216 | \tcm.mu.Lock()\nâ†’  217 | \tcm.stats.TotalUpdates++\n   218 | \tcm.mu.Unlock()\n   219 | \n   220 | \t// Update cache based on strategy\n   221 | \tswitch cm.config.Strategy {\n   222 | \tcase CoherencyStrategyWriteThrough:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\n   249 | \t\tLevel:                cm.config.Level,\n   250 | \t\tIsCoherent:           true, // Simplified\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\n   254 | \t}, nil\n   255 | }\n   256 | \n   257 | // GetInvalidationStats returns invalidation statistics\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\treturn \u0026CoherencyStatus{\n\t\tStrategy:             cm.config.Strategy,\n\t\tLevel:                cm.config.Level,\n\t\tIsCoherent:           true, // Simplified\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\n   338 | \tcm.pendingInvalidations[event.Key] = event\n   339 | \tcm.mu.Unlock()\n   340 | \n   341 | \t// Process invalidation\nâ†’  342 | \tcm.cache.Delete(event.Key)\n   343 | \n   344 | \tcm.mu.Lock()\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\n   346 | \tcm.mu.Unlock()\n   347 | \n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\n\tcm.mu.Lock()\n\tcm.pendingInvalidations[event.Key] = event\n\tcm.mu.Unlock()\n\n\t// Process invalidation\n\tcm.cache.Delete(event.Key)\n\n\tcm.mu.Lock()\n\tdelete(cm.pendingInvalidations, event.Key)\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Invalidation processed\",\n\t\tzap.String(\"key\", event.Key),\n\t\tzap.String(\"reason\", event.Reason))\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\n   245 | \n   246 | // ReplayFromSnapshot replays events from a snapshot version\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n   248 | \t// Get snapshot\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n   250 | \tif err != nil {\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n   252 | \t}\n   253 | \n   254 | \t// Get events after snapshot version\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n\t// Get snapshot\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n\t}\n\n\t// Get events after snapshot version\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\n\t}\n\n\tif len(events) == 0 {\n\t\treturn \u0026ReplayProgress{\n\t\t\tTotalEvents:     0,\n\t\t\tProcessedEvents: 0,\n\t\t\tIsComplete:      true,\n\t\t}, nil\n\t}\n\n\tstartTime := time.Now()\n\tprogress := \u0026ReplayProgress{\n\t\tTotalEvents:    int64(len(events)),\n\t\tStartTime:      startTime,\n\t\tCurrentVersion: snapshotVersion + 1,\n\t}\n\n\terr = er.replaySequential(ctx, events, handler, progress)\n\tprogress.ElapsedTime = time.Since(startTime)\n\tprogress.IsComplete = true\n\n\tif err != nil {\n\t\tprogress.LastError = err.Error()\n\t\treturn progress, err\n\t}\n\n\treturn progress, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\n   286 | \n   287 | // ReplayToState replays events to rebuild state at a specific version\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\n   289 | \t// Get all events up to target version\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\n   291 | \tif err != nil {\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\n   293 | \t}\n   294 | \n   295 | \t// Replay events\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\n   136 | \t\t// Return copy\n   137 | \t\tcopy := *versionInfo\n   138 | \t\tif versionInfo.VersionHistory != nil {\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n   141 | \t\t}\n   142 | \t\treturn \u0026copy, nil\n   143 | \t}\n   144 | \n   145 | \t// Load from event store\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\n\tev.mu.RLock()\n\tversionInfo, exists := ev.versions[aggregateID]\n\tev.mu.RUnlock()\n\n\tif exists {\n\t\t// Return copy\n\t\tcopy := *versionInfo\n\t\tif versionInfo.VersionHistory != nil {\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n\t\t}\n\t\treturn \u0026copy, nil\n\t}\n\n\t// Load from event store\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t}\n\n\tversionInfo = \u0026VersionInfo{\n\t\tAggregateID:    aggregateID,\n\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\tCurrentVersion: aggregateInfo.Version,\n\t\tMetadata:       make(map[string]interface{}),\n\t}\n\n\tif ev.config.EnableHistory {\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t}\n\n\tev.mu.Lock()\n\tev.versions[aggregateID] = versionInfo\n\tev.mu.Unlock()\n\n\treturn versionInfo, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n   213 | \t\t}\n   214 | \n   215 | \t\t// Resolve conflict\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n   217 | \t\tif err != nil {\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n   219 | \t\t}\n   220 | \n   221 | \t\tnewVersion = resolvedVersion\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\n\tev.mu.Lock()\n\tdefer ev.mu.Unlock()\n\n\tversionInfo, exists := ev.versions[aggregateID]\n\tif !exists {\n\t\t// Load from store\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t\t}\n\n\t\tversionInfo = \u0026VersionInfo{\n\t\t\tAggregateID:    aggregateID,\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\t\tCurrentVersion: aggregateInfo.Version,\n\t\t\tMetadata:       make(map[string]interface{}),\n\t\t}\n\n\t\tif ev.config.EnableHistory {\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t\t}\n\n\t\tev.versions[aggregateID] = versionInfo\n\t}\n\n\t// Increment version\n\tnewVersion := versionInfo.CurrentVersion + 1\n\n\t// Validate version continuity\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\n\t\tconflict := \u0026VersionConflict{\n\t\t\tAggregateID:     aggregateID,\n\t\t\tExpectedVersion: newVersion,\n\t\t\tActualVersion:   event.Version,\n\t\t\tConflictTime:    time.Now(),\n\t\t}\n\n\t\tev.stats.TotalConflicts++\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\n\n\t\tif ev.config.ConflictResolution == \"reject\" {\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n\t\t}\n\n\t\t// Resolve conflict\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n\t\t}\n\n\t\tnewVersion = resolvedVersion\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\n\t\tev.stats.ResolvedConflicts++\n\t}\n\n\t// Update version info\n\tversionInfo.CurrentVersion = newVersion\n\tversionInfo.LastEventID = event.ID\n\tversionInfo.LastEventTime = event.Timestamp\n\n\t// Add to history\n\tif ev.config.EnableHistory {\n\t\tentry := VersionHistoryEntry{\n\t\t\tVersion:   newVersion,\n\t\t\tEventID:   event.ID,\n\t\t\tTimestamp: event.Timestamp,\n\t\t\tEventType: event.Type,\n\t\t}\n\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\n\n\t\t// Trim history if needed\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\n\t\t}\n\t}\n\n\t// Update statistics\n\tev.stats.TotalVersions++\n\tev.stats.VersionDistribution[newVersion]++\n\n\tev.logger.Debug(\"Version incremented\",\n\t\tzap.String(\"aggregate_id\", aggregateID),\n\t\tzap.Int64(\"version\", newVersion))\n\n\treturn newVersion, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\n     6 | \t\"os\"\n     7 | \t\"path/filepath\"\n     8 | \t\"time\"\n     9 | \nâ†’   10 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n    11 | \t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n    12 | \t\"go.uber.org/zap\"\n    13 | )\n    14 | \n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n",
          "full_function": "\t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\ntype HybridDeployer struct {\n\tdockerDeployer     *DockerDeployer\n\tkubernetesDeployer *KubernetesDeployer\n\tserverlessDeployer *ServerlessDeployer\n\tlogger             *zap.Logger\n}",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 11,
        "affected_lines": 38,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "30-60 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    }
  ],
  "high": null,
  "medium": null,
  "low": [
    {
      "type": "Linter limpo",
      "severity": "low",
      "location": "multiplos arquivos",
      "description": "âœ— FAIL: 24 issues crÃ­ticos, 0 warnings",
      "suggestion": "Corrija os issues FAIL primeiro, depois warnings",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": [
          {
            "tool_name": "golangci-lint",
            "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
            "diagnose_command": "golangci-lint run",
            "fix_command": "# NAO use --fix automaticamente, revise cada issue",
            "config_required": true,
            "config_template": ".golangci.yml com linters selecionados",
            "documentation": "https://golangci-lint.run/",
            "alternative_tools": null
          },
          {
            "tool_name": "staticcheck",
            "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
            "diagnose_command": "staticcheck ./...",
            "fix_command": "# Manual - staticcheck nao tem auto-fix",
            "config_required": false,
            "config_template": "",
            "documentation": "https://staticcheck.io/",
            "alternative_tools": null
          },
          {
            "tool_name": "gosec",
            "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
            "diagnose_command": "gosec ./...",
            "fix_command": "# Manual - corrija issues de seguranca",
            "config_required": false,
            "config_template": "",
            "documentation": "https://github.com/securego/gosec",
            "alternative_tools": null
          }
        ],
        "executable_steps": null,
        "estimated_time": "48m",
        "confidence": 0
      },
      "examples": [
        "ðŸ“¦ MÃ³dulos analisados: 1",
        "ðŸ“„ Linter Report v6: JSON + SARIF gerados",
        "",
        "ðŸ“Š Resumo por ferramenta (todos os mÃ³dulos):",
        "  â€¢ golangci-lint: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ govet: ð„‚ 24 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ staticcheck: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "",
        "ðŸ” Top issues prioritÃ¡rios (FAIL):",
        "  1. [govet] internal/mcp/generators/generator_factory.go:317 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  2. [govet] internal/mcp/generators/generator_factory.go:319 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  3. [govet] internal/mcp/generators/generator_factory.go:323 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  4. [govet] internal/mcp/generators/generator_factory.go:334 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  5. [govet] internal/mcp/generators/generator_factory.go:350 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  6. [govet] internal/mcp/generators/tinygo_generator.go:324 - cannot use \"project\" (untyped string constant) as zap.Field value in a... (govet)",
        "  7. [govet] internal/mcp/generators/tinygo_generator.go:324 - cannot use req.Name (variable of type string) as zap.Field value in ar... (govet)",
        "  8. [govet] internal/mcp/generators/tinygo_generator.go:325 - cannot use \"language\" (untyped string constant) as zap.Field value in ... (govet)",
        "  9. [govet] internal/mcp/generators/tinygo_generator.go:325 - cannot use g.language (variable of type string) as zap.Field value in ... (govet)",
        "  10. [govet] internal/mcp/generators/tinygo_generator.go:326 - cannot use \"features\" (untyped string constant) as zap.Field value in ... (govet)"
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": null,
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 24,
        "affected_lines": 24,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "48m",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [
        "performance",
        "memory-optimization"
      ],
      "error_breakdown": {
        "govet": 24
      },
      "top_files": [
        "internal/mcp/generators/tinygo_generator.go (6)",
        "internal/mcp/generators/generator_factory.go (5)",
        "pkg/httpserver/server_test.go (2)",
        "tools/deployers/hybrid_deployer.go (1)",
        "vet.exe: internal/ai/knowledge/indexer_test.go (1)"
      ]
    }
  ],
  "total_gaps": 3,
  "score": 85,
  "auto_fixable": 0,
  "manual": 3,
  "top_priorities": [
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(generateCmd)\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\n    49 | }\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(generateCmd)\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n\tgenerateCmd.MarkFlagRequired(\"template\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\n    20 | \t\treturn nil\n    21 | \t},\n    22 | }\n    23 | \nâ†’   24 | func init() {\n    25 | \trootCmd.AddCommand(monitorCmd)\n    26 | }\n    27 | \n    28 | // SetMonitoringService sets the monitoring service\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(monitorCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 37,
          "code_snippet": "    32 | \t\tos.Exit(1)\n    33 | \t}\n    34 | }\n    35 | \n    36 | // init initializes the CLI\nâ†’   37 | func init() {\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\n    16 | \t\treturn nil\n    17 | \t},\n    18 | }\n    19 | \nâ†’   20 | func init() {\n    21 | \trootCmd.AddCommand(stateCmd)\n    22 | }\n    23 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(stateCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(templateCmd)\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(templateCmd)\n\ttemplateCmd.AddCommand(templateListCmd)\n\ttemplateCmd.AddCommand(templateCreateCmd)\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\n    18 | \t},\n    19 | }\n    20 | \nâ†’   21 | func init() {\n    22 | \trootCmd.AddCommand(versionCmd)\n    23 | }\n    24 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(versionCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\n    19 | \t\treturn nil\n    20 | \t},\n    21 | }\n    22 | \nâ†’   23 | func init() {\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\n    25 | }\n    26 | \n",
          "full_function": "func init() {\n\tAnalyticsCmd.AddCommand(performanceCmd)\n}",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators\ninternal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)\ninternal\\...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\docs\\validation\\raw\\2025-11-21-16-06-19-compilation.log",
        "",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
        "internal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:319:50: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:323:54: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:334:75: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:350:39: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\tinygo_generator.go:324:3: cannot use \"project\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:324:14: cannot use req.Name (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:3: cannot use \"language\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:15: cannot use g.language (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: cannot use \"features\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: too many errors",
        "# github.com/vertikon/mcp-fulfillment-ops/cmd/fulfillment-ops",
        "cmd\\fulfillment-ops\\main.go:13:2: \"github.com/gin-gonic/gin\" imported and not used",
        "cmd\\fulfillment-ops\\main.go:16:2: \"github.com/nats-io/nats.go/jetstream\" imported and not used",
        "cmd\\fulfillment-ops\\main.go:89:50: cannot use js (variable of interface type \"github.com/nats-io/nats.go\".JetStreamContext) as jetstream.JetStream value in argument to natsAdapter.NewEventPublisher: \"github.com/nats-io/nats.go\".JetStreamContext does not implement jetstream.JetStream (wrong type for method AccountInfo)",
        "\t\thave AccountInfo(...\"github.com/nats-io/nats.go\".JSOpt) (*\"github.com/nats-io/nats.go\".AccountInfo, error)",
        "\t\twant AccountInfo(context.Context) (*jetstream.AccountInfo, error)",
        "cmd\\fulfillment-ops\\main.go:100:53: cannot use js (variable of interface type \"github.com/nats-io/nats.go\".JetStreamContext) as jetstream.JetStream value in argument to natsAdapter.NewFulfillmentSubscriber: \"github.com/nats-io/nats.go\".JetStreamContext does not implement jetstream.JetStream (wrong type for method AccountInfo)",
        "\t\thave AccountInfo(...\"github.com/nats-io/nats.go\".JSOpt) (*\"github.com/nats-io/nats.go\".AccountInfo, error)",
        "\t\twant AccountInfo(context.Context) (*jetstream.AccountInfo, error)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/cli",
        "internal\\interfaces\\cli\\root.go:42:21: undefined: analytics",
        "internal\\interfaces\\cli\\root.go:43:21: undefined: ci",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/security/config",
        "internal\\security\\config\\integration.go:215:26: ruleCfg.Resource undefined (type PolicyRuleConfig has no field or method Resource)",
        "internal\\security\\config\\integration.go:216:26: ruleCfg.Action undefined (type PolicyRuleConfig has no field or method Action)",
        "internal\\security\\config\\integration.go:218:26: ruleCfg.Description undefined (type PolicyRuleConfig has no field or method Description)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        "# github.com/vertikon/mcp-fulfillment-ops/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\" imported and not used",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 317,
          "code_snippet": "   312 | \tif req.Path == \"\" {\n   313 | \t\treturn fmt.Errorf(\"output path is required\")\n   314 | \t}\n   315 | \n   316 | \t// Check if stack is supported\nâ†’  317 | \t_, exists := f.generators[req.Stack]\n   318 | \tif !exists {\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 319,
          "code_snippet": "   314 | \t}\n   315 | \n   316 | \t// Check if stack is supported\n   317 | \t_, exists := f.generators[req.Stack]\n   318 | \tif !exists {\nâ†’  319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\n   323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n   324 | \t\t// Validate features\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 323,
          "code_snippet": "   318 | \tif !exists {\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\nâ†’  323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n   324 | \t\t// Validate features\n   325 | \t\tfor _, feature := range req.Features {\n   326 | \t\t\tvalidFeature := false\n   327 | \t\t\tfor _, validFeat := range stackConfig.Features {\n   328 | \t\t\t\tif feature == validFeat {\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 334,
          "code_snippet": "   329 | \t\t\t\t\tvalidFeature = true\n   330 | \t\t\t\t\tbreak\n   331 | \t\t\t\t}\n   332 | \t\t\t}\n   333 | \t\t\tif !validFeature {\nâ†’  334 | \t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n   335 | \t\t\t}\n   336 | \t\t}\n   337 | \t}\n   338 | \n   339 | \treturn nil\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 350,
          "code_snippet": "   345 | \tif err := f.ValidateRequest(req); err != nil {\n   346 | \t\treturn nil, err\n   347 | \t}\n   348 | \n   349 | \t// Get generator\nâ†’  350 | \tgenerator, err := f.GetGenerator(req.Stack)\n   351 | \tif err != nil {\n   352 | \t\treturn nil, err\n   353 | \t}\n   354 | \n   355 | \t// Generate project\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\n   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\nâ†’  324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\n   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\nâ†’  324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\nâ†’  325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\nâ†’  325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\nâ†’  326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n   331 | // Validate validates wasm generator\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\nâ†’  326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n   331 | // Validate validates wasm generator\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 13,
          "code_snippet": "     8 | \t\"os\"\n     9 | \t\"os/signal\"\n    10 | \t\"syscall\"\n    11 | \t\"time\"\n    12 | \nâ†’   13 | \t\"github.com/gin-gonic/gin\"\n    14 | \t_ \"github.com/lib/pq\"\n    15 | \t\"github.com/nats-io/nats.go\"\n    16 | \t\"github.com/nats-io/nats.go/jetstream\"\n    17 | \t\"go.uber.org/zap\"\n    18 | \n",
          "full_function": "\t\"github.com/gin-gonic/gin\"\n\t_ \"github.com/lib/pq\"\n\t\"github.com/nats-io/nats.go\"\n\t\"github.com/nats-io/nats.go/jetstream\"\n\t\"go.uber.org/zap\"\n\n\tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n\tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/app\"\n\thttpHandler \"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http\"\n)\n\nfunc main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 16,
          "code_snippet": "    11 | \t\"time\"\n    12 | \n    13 | \t\"github.com/gin-gonic/gin\"\n    14 | \t_ \"github.com/lib/pq\"\n    15 | \t\"github.com/nats-io/nats.go\"\nâ†’   16 | \t\"github.com/nats-io/nats.go/jetstream\"\n    17 | \t\"go.uber.org/zap\"\n    18 | \n    19 | \tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n    20 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n    21 | \tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n",
          "full_function": "\t\"github.com/nats-io/nats.go/jetstream\"\n\t\"go.uber.org/zap\"\n\n\tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n\tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/app\"\n\thttpHandler \"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http\"\n)\n\nfunc main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 89,
          "code_snippet": "    84 | \tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n    85 | \tappLogger := app.NewZapLoggerAdapter(logger)\n    86 | \n    87 | \t// Criar adapters\n    88 | \tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\nâ†’   89 | \teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n    90 | \n    91 | \t// Criar casos de uso\n    92 | \treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    93 | \tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    94 | \tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n",
          "full_function": "func main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 100,
          "code_snippet": "    95 | \tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    96 | \topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n    97 | \tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    98 | \n    99 | \t// Iniciar subscriber NATS para eventos OMS\nâ†’  100 | \tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n   101 | \tctx, cancel := context.WithCancel(context.Background())\n   102 | \tdefer cancel()\n   103 | \n   104 | \tif err := subscriber.Start(ctx); err != nil {\n   105 | \t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n",
          "full_function": "func main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\n    10 | \t// Invoke invokes a cloud function\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\n    12 | \n    13 | \t// CreateFunction creates a cloud function\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\n    15 | \n    16 | \t// DeleteFunction deletes a cloud function\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\n    18 | }\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 42,
          "code_snippet": "    37 | func init() {\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\nâ†’   42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n    43 | \trootCmd.AddCommand(ci.CICmd)\n    44 | }\n    45 | \n    46 | // GetRootCmd returns the root command (for testing)\n    47 | func GetRootCmd() *cobra.Command {\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 43,
          "code_snippet": "    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\nâ†’   43 | \trootCmd.AddCommand(ci.CICmd)\n    44 | }\n    45 | \n    46 | // GetRootCmd returns the root command (for testing)\n    47 | func GetRootCmd() *cobra.Command {\n    48 | \treturn rootCmd\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 215,
          "code_snippet": "   210 | \t\t\tif ruleCfg.Effect == \"deny\" {\n   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\nâ†’  215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\nâ†’  216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 218,
          "code_snippet": "   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\nâ†’  218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n   222 | \t\t\t}\n   223 | \t\t\tpolicy.Rules = append(policy.Rules, rule)\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\n   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n   242 | \tdefault:\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\n   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n   257 | \n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n   279 | \t// For simple values, use last-write-wins\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\n   281 | \n   282 | \t// Check if values are mergeable\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n   285 | \t\tif err != nil {\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\n   288 | \t\t\t\tzap.Error(err))\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n\t// For simple values, use last-write-wins\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\n\n\t// Check if values are mergeable\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n\t\tif err != nil {\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n\t\t\t\tzap.String(\"key\", conflict.Key),\n\t\t\t\tzap.Error(err))\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\n\t\t}\n\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   mergedValue,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\n\t\t}, nil\n\t}\n\n\t// Non-mergeable, fall back to LWW\n\treturn r.resolveCRDTLastWriterWins(conflict)\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\n   392 | }\n   393 | \n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\n   395 | \t// Check if value is a type that can be merged\nâ†’  396 | \tswitch v := value.(type) {\n   397 | \tcase map[string]interface{}:\n   398 | \t\treturn true\n   399 | \tcase []interface{}:\n   400 | \t\treturn true\n   401 | \tcase map[string]string:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\n   411 | \t// Implement actual CRDT merge logic based on value type\n   412 | \tswitch l := local.(type) {\n   413 | \tcase map[string]interface{}:\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n   421 | \t}\n   422 | \n   423 | \t// Cannot merge, return error\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\n   158 | \tcm.stats.InvalidationsByReason[reason]++\n   159 | \tcm.mu.Unlock()\n   160 | \n   161 | \t// Delete from cache\nâ†’  162 | \tcm.cache.Delete(key)\n   163 | \n   164 | \t// Create invalidation event\n   165 | \tevent := \u0026InvalidationEvent{\n   166 | \t\tKey:       key,\n   167 | \t\tReason:    reason,\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\n\tstart := time.Now()\n\n\tcm.mu.Lock()\n\tcm.stats.TotalInvalidations++\n\tcm.stats.InvalidationsByReason[reason]++\n\tcm.mu.Unlock()\n\n\t// Delete from cache\n\tcm.cache.Delete(key)\n\n\t// Create invalidation event\n\tevent := \u0026InvalidationEvent{\n\t\tKey:       key,\n\t\tReason:    reason,\n\t\tTimestamp: time.Now(),\n\t\tSource:    \"coherency_manager\",\n\t}\n\n\t// Send to invalidation channel\n\tselect {\n\tcase cm.invalidationCh \u003c- event:\n\tdefault:\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\n\t\t\tzap.String(\"key\", key))\n\t}\n\n\tcm.mu.Lock()\n\tcm.stats.AverageInvalidationTime = time.Since(start)\n\tlastTime := time.Now()\n\tcm.stats.LastInvalidation = \u0026lastTime\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Cache key invalidated\",\n\t\tzap.String(\"key\", key),\n\t\tzap.String(\"reason\", reason))\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\n   213 | \n   214 | // Update updates a cache entry\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\n   216 | \tcm.mu.Lock()\nâ†’  217 | \tcm.stats.TotalUpdates++\n   218 | \tcm.mu.Unlock()\n   219 | \n   220 | \t// Update cache based on strategy\n   221 | \tswitch cm.config.Strategy {\n   222 | \tcase CoherencyStrategyWriteThrough:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\n   249 | \t\tLevel:                cm.config.Level,\n   250 | \t\tIsCoherent:           true, // Simplified\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\n   254 | \t}, nil\n   255 | }\n   256 | \n   257 | // GetInvalidationStats returns invalidation statistics\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\treturn \u0026CoherencyStatus{\n\t\tStrategy:             cm.config.Strategy,\n\t\tLevel:                cm.config.Level,\n\t\tIsCoherent:           true, // Simplified\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\n   338 | \tcm.pendingInvalidations[event.Key] = event\n   339 | \tcm.mu.Unlock()\n   340 | \n   341 | \t// Process invalidation\nâ†’  342 | \tcm.cache.Delete(event.Key)\n   343 | \n   344 | \tcm.mu.Lock()\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\n   346 | \tcm.mu.Unlock()\n   347 | \n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\n\tcm.mu.Lock()\n\tcm.pendingInvalidations[event.Key] = event\n\tcm.mu.Unlock()\n\n\t// Process invalidation\n\tcm.cache.Delete(event.Key)\n\n\tcm.mu.Lock()\n\tdelete(cm.pendingInvalidations, event.Key)\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Invalidation processed\",\n\t\tzap.String(\"key\", event.Key),\n\t\tzap.String(\"reason\", event.Reason))\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\n   245 | \n   246 | // ReplayFromSnapshot replays events from a snapshot version\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n   248 | \t// Get snapshot\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n   250 | \tif err != nil {\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n   252 | \t}\n   253 | \n   254 | \t// Get events after snapshot version\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n\t// Get snapshot\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n\t}\n\n\t// Get events after snapshot version\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\n\t}\n\n\tif len(events) == 0 {\n\t\treturn \u0026ReplayProgress{\n\t\t\tTotalEvents:     0,\n\t\t\tProcessedEvents: 0,\n\t\t\tIsComplete:      true,\n\t\t}, nil\n\t}\n\n\tstartTime := time.Now()\n\tprogress := \u0026ReplayProgress{\n\t\tTotalEvents:    int64(len(events)),\n\t\tStartTime:      startTime,\n\t\tCurrentVersion: snapshotVersion + 1,\n\t}\n\n\terr = er.replaySequential(ctx, events, handler, progress)\n\tprogress.ElapsedTime = time.Since(startTime)\n\tprogress.IsComplete = true\n\n\tif err != nil {\n\t\tprogress.LastError = err.Error()\n\t\treturn progress, err\n\t}\n\n\treturn progress, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\n   286 | \n   287 | // ReplayToState replays events to rebuild state at a specific version\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\n   289 | \t// Get all events up to target version\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\n   291 | \tif err != nil {\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\n   293 | \t}\n   294 | \n   295 | \t// Replay events\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\n   136 | \t\t// Return copy\n   137 | \t\tcopy := *versionInfo\n   138 | \t\tif versionInfo.VersionHistory != nil {\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n   141 | \t\t}\n   142 | \t\treturn \u0026copy, nil\n   143 | \t}\n   144 | \n   145 | \t// Load from event store\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\n\tev.mu.RLock()\n\tversionInfo, exists := ev.versions[aggregateID]\n\tev.mu.RUnlock()\n\n\tif exists {\n\t\t// Return copy\n\t\tcopy := *versionInfo\n\t\tif versionInfo.VersionHistory != nil {\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n\t\t}\n\t\treturn \u0026copy, nil\n\t}\n\n\t// Load from event store\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t}\n\n\tversionInfo = \u0026VersionInfo{\n\t\tAggregateID:    aggregateID,\n\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\tCurrentVersion: aggregateInfo.Version,\n\t\tMetadata:       make(map[string]interface{}),\n\t}\n\n\tif ev.config.EnableHistory {\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t}\n\n\tev.mu.Lock()\n\tev.versions[aggregateID] = versionInfo\n\tev.mu.Unlock()\n\n\treturn versionInfo, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n   213 | \t\t}\n   214 | \n   215 | \t\t// Resolve conflict\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n   217 | \t\tif err != nil {\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n   219 | \t\t}\n   220 | \n   221 | \t\tnewVersion = resolvedVersion\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\n\tev.mu.Lock()\n\tdefer ev.mu.Unlock()\n\n\tversionInfo, exists := ev.versions[aggregateID]\n\tif !exists {\n\t\t// Load from store\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t\t}\n\n\t\tversionInfo = \u0026VersionInfo{\n\t\t\tAggregateID:    aggregateID,\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\t\tCurrentVersion: aggregateInfo.Version,\n\t\t\tMetadata:       make(map[string]interface{}),\n\t\t}\n\n\t\tif ev.config.EnableHistory {\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t\t}\n\n\t\tev.versions[aggregateID] = versionInfo\n\t}\n\n\t// Increment version\n\tnewVersion := versionInfo.CurrentVersion + 1\n\n\t// Validate version continuity\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\n\t\tconflict := \u0026VersionConflict{\n\t\t\tAggregateID:     aggregateID,\n\t\t\tExpectedVersion: newVersion,\n\t\t\tActualVersion:   event.Version,\n\t\t\tConflictTime:    time.Now(),\n\t\t}\n\n\t\tev.stats.TotalConflicts++\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\n\n\t\tif ev.config.ConflictResolution == \"reject\" {\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n\t\t}\n\n\t\t// Resolve conflict\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n\t\t}\n\n\t\tnewVersion = resolvedVersion\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\n\t\tev.stats.ResolvedConflicts++\n\t}\n\n\t// Update version info\n\tversionInfo.CurrentVersion = newVersion\n\tversionInfo.LastEventID = event.ID\n\tversionInfo.LastEventTime = event.Timestamp\n\n\t// Add to history\n\tif ev.config.EnableHistory {\n\t\tentry := VersionHistoryEntry{\n\t\t\tVersion:   newVersion,\n\t\t\tEventID:   event.ID,\n\t\t\tTimestamp: event.Timestamp,\n\t\t\tEventType: event.Type,\n\t\t}\n\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\n\n\t\t// Trim history if needed\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\n\t\t}\n\t}\n\n\t// Update statistics\n\tev.stats.TotalVersions++\n\tev.stats.VersionDistribution[newVersion]++\n\n\tev.logger.Debug(\"Version incremented\",\n\t\tzap.String(\"aggregate_id\", aggregateID),\n\t\tzap.Int64(\"version\", newVersion))\n\n\treturn newVersion, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\n     6 | \t\"os\"\n     7 | \t\"path/filepath\"\n     8 | \t\"time\"\n     9 | \nâ†’   10 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n    11 | \t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n    12 | \t\"go.uber.org/zap\"\n    13 | )\n    14 | \n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n",
          "full_function": "\t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\ntype HybridDeployer struct {\n\tdockerDeployer     *DockerDeployer\n\tkubernetesDeployer *KubernetesDeployer\n\tserverlessDeployer *ServerlessDeployer\n\tlogger             *zap.Logger\n}",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 11,
        "affected_lines": 38,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "30-60 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Linter limpo",
      "severity": "low",
      "location": "multiplos arquivos",
      "description": "âœ— FAIL: 24 issues crÃ­ticos, 0 warnings",
      "suggestion": "Corrija os issues FAIL primeiro, depois warnings",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": [
          {
            "tool_name": "golangci-lint",
            "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
            "diagnose_command": "golangci-lint run",
            "fix_command": "# NAO use --fix automaticamente, revise cada issue",
            "config_required": true,
            "config_template": ".golangci.yml com linters selecionados",
            "documentation": "https://golangci-lint.run/",
            "alternative_tools": null
          },
          {
            "tool_name": "staticcheck",
            "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
            "diagnose_command": "staticcheck ./...",
            "fix_command": "# Manual - staticcheck nao tem auto-fix",
            "config_required": false,
            "config_template": "",
            "documentation": "https://staticcheck.io/",
            "alternative_tools": null
          },
          {
            "tool_name": "gosec",
            "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
            "diagnose_command": "gosec ./...",
            "fix_command": "# Manual - corrija issues de seguranca",
            "config_required": false,
            "config_template": "",
            "documentation": "https://github.com/securego/gosec",
            "alternative_tools": null
          }
        ],
        "executable_steps": null,
        "estimated_time": "48m",
        "confidence": 0
      },
      "examples": [
        "ðŸ“¦ MÃ³dulos analisados: 1",
        "ðŸ“„ Linter Report v6: JSON + SARIF gerados",
        "",
        "ðŸ“Š Resumo por ferramenta (todos os mÃ³dulos):",
        "  â€¢ golangci-lint: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ govet: ð„‚ 24 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ staticcheck: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "",
        "ðŸ” Top issues prioritÃ¡rios (FAIL):",
        "  1. [govet] internal/mcp/generators/generator_factory.go:317 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  2. [govet] internal/mcp/generators/generator_factory.go:319 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  3. [govet] internal/mcp/generators/generator_factory.go:323 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  4. [govet] internal/mcp/generators/generator_factory.go:334 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  5. [govet] internal/mcp/generators/generator_factory.go:350 - req.Stack undefined (type GenerateRequest has no field or method Stack... (govet)",
        "  6. [govet] internal/mcp/generators/tinygo_generator.go:324 - cannot use \"project\" (untyped string constant) as zap.Field value in a... (govet)",
        "  7. [govet] internal/mcp/generators/tinygo_generator.go:324 - cannot use req.Name (variable of type string) as zap.Field value in ar... (govet)",
        "  8. [govet] internal/mcp/generators/tinygo_generator.go:325 - cannot use \"language\" (untyped string constant) as zap.Field value in ... (govet)",
        "  9. [govet] internal/mcp/generators/tinygo_generator.go:325 - cannot use g.language (variable of type string) as zap.Field value in ... (govet)",
        "  10. [govet] internal/mcp/generators/tinygo_generator.go:326 - cannot use \"features\" (untyped string constant) as zap.Field value in ... (govet)"
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": null,
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 24,
        "affected_lines": 24,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "48m",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [
        "performance",
        "memory-optimization"
      ],
      "error_breakdown": {
        "govet": 24
      },
      "top_files": [
        "internal/mcp/generators/tinygo_generator.go (6)",
        "internal/mcp/generators/generator_factory.go (5)",
        "pkg/httpserver/server_test.go (2)",
        "tools/deployers/hybrid_deployer.go (1)",
        "vet.exe: internal/ai/knowledge/indexer_test.go (1)"
      ]
    }
  ],
  "quick_wins": null,
  "blockers": [
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(generateCmd)\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\n    49 | }\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(generateCmd)\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\n\tgenerateCmd.MarkFlagRequired(\"template\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\n    20 | \t\treturn nil\n    21 | \t},\n    22 | }\n    23 | \nâ†’   24 | func init() {\n    25 | \trootCmd.AddCommand(monitorCmd)\n    26 | }\n    27 | \n    28 | // SetMonitoringService sets the monitoring service\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(monitorCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 37,
          "code_snippet": "    32 | \t\tos.Exit(1)\n    33 | \t}\n    34 | }\n    35 | \n    36 | // init initializes the CLI\nâ†’   37 | func init() {\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\n    16 | \t\treturn nil\n    17 | \t},\n    18 | }\n    19 | \nâ†’   20 | func init() {\n    21 | \trootCmd.AddCommand(stateCmd)\n    22 | }\n    23 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(stateCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\n    40 | \t\treturn nil\n    41 | \t},\n    42 | }\n    43 | \nâ†’   44 | func init() {\n    45 | \trootCmd.AddCommand(templateCmd)\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\n",
          "full_function": "func init() {\n\trootCmd.AddCommand(templateCmd)\n\ttemplateCmd.AddCommand(templateListCmd)\n\ttemplateCmd.AddCommand(templateCreateCmd)\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/internal/services",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\n    18 | \t},\n    19 | }\n    20 | \nâ†’   21 | func init() {\n    22 | \trootCmd.AddCommand(versionCmd)\n    23 | }\n    24 | \n",
          "full_function": "func init() {\n\trootCmd.AddCommand(versionCmd)\n}",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\n    19 | \t\treturn nil\n    20 | \t},\n    21 | }\n    22 | \nâ†’   23 | func init() {\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\n    25 | }\n    26 | \n",
          "full_function": "func init() {\n\tAnalyticsCmd.AddCommand(performanceCmd)\n}",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators\ninternal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)\ninternal\\...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\docs\\validation\\raw\\2025-11-21-16-06-19-compilation.log",
        "",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/mcp/generators",
        "internal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:319:50: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:323:54: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:334:75: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:350:39: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\tinygo_generator.go:324:3: cannot use \"project\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:324:14: cannot use req.Name (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:3: cannot use \"language\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:15: cannot use g.language (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: cannot use \"features\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: too many errors",
        "# github.com/vertikon/mcp-fulfillment-ops/cmd/fulfillment-ops",
        "cmd\\fulfillment-ops\\main.go:13:2: \"github.com/gin-gonic/gin\" imported and not used",
        "cmd\\fulfillment-ops\\main.go:16:2: \"github.com/nats-io/nats.go/jetstream\" imported and not used",
        "cmd\\fulfillment-ops\\main.go:89:50: cannot use js (variable of interface type \"github.com/nats-io/nats.go\".JetStreamContext) as jetstream.JetStream value in argument to natsAdapter.NewEventPublisher: \"github.com/nats-io/nats.go\".JetStreamContext does not implement jetstream.JetStream (wrong type for method AccountInfo)",
        "\t\thave AccountInfo(...\"github.com/nats-io/nats.go\".JSOpt) (*\"github.com/nats-io/nats.go\".AccountInfo, error)",
        "\t\twant AccountInfo(context.Context) (*jetstream.AccountInfo, error)",
        "cmd\\fulfillment-ops\\main.go:100:53: cannot use js (variable of interface type \"github.com/nats-io/nats.go\".JetStreamContext) as jetstream.JetStream value in argument to natsAdapter.NewFulfillmentSubscriber: \"github.com/nats-io/nats.go\".JetStreamContext does not implement jetstream.JetStream (wrong type for method AccountInfo)",
        "\t\thave AccountInfo(...\"github.com/nats-io/nats.go\".JSOpt) (*\"github.com/nats-io/nats.go\".AccountInfo, error)",
        "\t\twant AccountInfo(context.Context) (*jetstream.AccountInfo, error)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/cli",
        "internal\\interfaces\\cli\\root.go:42:21: undefined: analytics",
        "internal\\interfaces\\cli\\root.go:43:21: undefined: ci",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/security/config",
        "internal\\security\\config\\integration.go:215:26: ruleCfg.Resource undefined (type PolicyRuleConfig has no field or method Resource)",
        "internal\\security\\config\\integration.go:216:26: ruleCfg.Action undefined (type PolicyRuleConfig has no field or method Action)",
        "internal\\security\\config\\integration.go:218:26: ruleCfg.Description undefined (type PolicyRuleConfig has no field or method Description)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-fulfillment-ops/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        "# github.com/vertikon/mcp-fulfillment-ops/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\" imported and not used",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 317,
          "code_snippet": "   312 | \tif req.Path == \"\" {\n   313 | \t\treturn fmt.Errorf(\"output path is required\")\n   314 | \t}\n   315 | \n   316 | \t// Check if stack is supported\nâ†’  317 | \t_, exists := f.generators[req.Stack]\n   318 | \tif !exists {\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 319,
          "code_snippet": "   314 | \t}\n   315 | \n   316 | \t// Check if stack is supported\n   317 | \t_, exists := f.generators[req.Stack]\n   318 | \tif !exists {\nâ†’  319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\n   323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n   324 | \t\t// Validate features\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 323,
          "code_snippet": "   318 | \tif !exists {\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n   320 | \t}\n   321 | \n   322 | \t// Validate stack configuration\nâ†’  323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n   324 | \t\t// Validate features\n   325 | \t\tfor _, feature := range req.Features {\n   326 | \t\t\tvalidFeature := false\n   327 | \t\t\tfor _, validFeat := range stackConfig.Features {\n   328 | \t\t\t\tif feature == validFeat {\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 334,
          "code_snippet": "   329 | \t\t\t\t\tvalidFeature = true\n   330 | \t\t\t\t\tbreak\n   331 | \t\t\t\t}\n   332 | \t\t\t}\n   333 | \t\t\tif !validFeature {\nâ†’  334 | \t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n   335 | \t\t\t}\n   336 | \t\t}\n   337 | \t}\n   338 | \n   339 | \treturn nil\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\n\tif req.Name == \"\" {\n\t\treturn fmt.Errorf(\"project name is required\")\n\t}\n\n\tif req.Path == \"\" {\n\t\treturn fmt.Errorf(\"output path is required\")\n\t}\n\n\t// Check if stack is supported\n\t_, exists := f.generators[req.Stack]\n\tif !exists {\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\n\t}\n\n\t// Validate stack configuration\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\n\t\t// Validate features\n\t\tfor _, feature := range req.Features {\n\t\t\tvalidFeature := false\n\t\t\tfor _, validFeat := range stackConfig.Features {\n\t\t\t\tif feature == validFeat {\n\t\t\t\t\tvalidFeature = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !validFeature {\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 350,
          "code_snippet": "   345 | \tif err := f.ValidateRequest(req); err != nil {\n   346 | \t\treturn nil, err\n   347 | \t}\n   348 | \n   349 | \t// Get generator\nâ†’  350 | \tgenerator, err := f.GetGenerator(req.Stack)\n   351 | \tif err != nil {\n   352 | \t\treturn nil, err\n   353 | \t}\n   354 | \n   355 | \t// Generate project\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\n   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\nâ†’  324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\n   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\nâ†’  324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\nâ†’  325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\n   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\nâ†’  325 | \t\t\"language\", g.language,\n   326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\nâ†’  326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n   331 | // Validate validates wasm generator\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\n   322 | \n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\n   324 | \t\t\"project\", req.Name,\n   325 | \t\t\"language\", g.language,\nâ†’  326 | \t\t\"features\", req.Features)\n   327 | \n   328 | \treturn nil\n   329 | }\n   330 | \n   331 | // Validate validates wasm generator\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\n\t// Build WASM project\n\t// Compile to WebAssembly\n\t// Generate bindings\n\t// This would involve executing shell commands\n\t// For now, just return nil as placeholder\n\n\tg.logger.Info(\"WASM project post-processing completed\",\n\t\t\"project\", req.Name,\n\t\t\"language\", g.language,\n\t\t\"features\", req.Features)\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 13,
          "code_snippet": "     8 | \t\"os\"\n     9 | \t\"os/signal\"\n    10 | \t\"syscall\"\n    11 | \t\"time\"\n    12 | \nâ†’   13 | \t\"github.com/gin-gonic/gin\"\n    14 | \t_ \"github.com/lib/pq\"\n    15 | \t\"github.com/nats-io/nats.go\"\n    16 | \t\"github.com/nats-io/nats.go/jetstream\"\n    17 | \t\"go.uber.org/zap\"\n    18 | \n",
          "full_function": "\t\"github.com/gin-gonic/gin\"\n\t_ \"github.com/lib/pq\"\n\t\"github.com/nats-io/nats.go\"\n\t\"github.com/nats-io/nats.go/jetstream\"\n\t\"go.uber.org/zap\"\n\n\tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n\tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/app\"\n\thttpHandler \"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http\"\n)\n\nfunc main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 16,
          "code_snippet": "    11 | \t\"time\"\n    12 | \n    13 | \t\"github.com/gin-gonic/gin\"\n    14 | \t_ \"github.com/lib/pq\"\n    15 | \t\"github.com/nats-io/nats.go\"\nâ†’   16 | \t\"github.com/nats-io/nats.go/jetstream\"\n    17 | \t\"go.uber.org/zap\"\n    18 | \n    19 | \tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n    20 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n    21 | \tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n",
          "full_function": "\t\"github.com/nats-io/nats.go/jetstream\"\n\t\"go.uber.org/zap\"\n\n\tnatsAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres\"\n\tredisAdapter \"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/internal/app\"\n\thttpHandler \"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http\"\n)\n\nfunc main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 89,
          "code_snippet": "    84 | \tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n    85 | \tappLogger := app.NewZapLoggerAdapter(logger)\n    86 | \n    87 | \t// Criar adapters\n    88 | \tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\nâ†’   89 | \teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n    90 | \n    91 | \t// Criar casos de uso\n    92 | \treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    93 | \tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    94 | \tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n",
          "full_function": "func main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\cmd\\fulfillment-ops\\main.go",
          "line_number": 100,
          "code_snippet": "    95 | \tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    96 | \topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n    97 | \tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n    98 | \n    99 | \t// Iniciar subscriber NATS para eventos OMS\nâ†’  100 | \tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n   101 | \tctx, cancel := context.WithCancel(context.Background())\n   102 | \tdefer cancel()\n   103 | \n   104 | \tif err := subscriber.Start(ctx); err != nil {\n   105 | \t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n",
          "full_function": "func main() {\n\t// Carregar configuraÃ§Ã£o\n\tdbURL := getEnv(\"DATABASE_URL\", \"postgres://user:password@localhost/fulfillment?sslmode=disable\")\n\tnatsURL := getEnv(\"NATS_URL\", \"nats://localhost:4222\")\n\tredisURL := getEnv(\"REDIS_URL\", \"redis://localhost:6379\")\n\tcoreInventoryURL := getEnv(\"CORE_INVENTORY_URL\", \"http://localhost:8081\")\n\thttpPort := getEnv(\"HTTP_PORT\", \":8080\")\n\n\t// Inicializar logger\n\tlogger, err := zap.NewProduction()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to initialize logger: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer logger.Sync()\n\n\tlogger.Info(\"Starting mcp-fulfillment-ops server\")\n\n\t// Conectar ao banco de dados\n\tdb, err := sql.Open(\"postgres\", dbURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to database\", zap.Error(err))\n\t}\n\tdefer db.Close()\n\n\t// Verificar conexÃ£o com banco\n\tif err := db.Ping(); err != nil {\n\t\tlogger.Fatal(\"Failed to ping database\", zap.Error(err))\n\t}\n\tlogger.Info(\"Database connection established\")\n\n\t// Criar repositÃ³rio\n\trepo := postgres.NewFulfillmentRepository(db)\n\n\t// Conectar ao NATS\n\tnc, err := nats.Connect(natsURL)\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to connect to NATS\", zap.Error(err))\n\t}\n\tdefer nc.Close()\n\n\tjs, err := nc.JetStream()\n\tif err != nil {\n\t\tlogger.Fatal(\"Failed to get JetStream context\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS connection established\")\n\n\t// Conectar ao Redis\n\tredisClient, err := redisAdapter.NewRedisClient(redisURL)\n\tif err != nil {\n\t\tlogger.Warn(\"Failed to connect to Redis, continuing without cache\", zap.Error(err))\n\t\tredisClient = nil\n\t} else {\n\t\tlogger.Info(\"Redis connection established\")\n\t\tdefer redisClient.Close()\n\t}\n\n\t// Criar adapters de logger\n\tnatsLogger := natsAdapter.NewZapLoggerAdapter(logger)\n\tappLogger := app.NewZapLoggerAdapter(logger)\n\n\t// Criar adapters\n\tinventoryClient := natsAdapter.NewInventoryCommandClient(coreInventoryURL, natsLogger)\n\teventPublisher := natsAdapter.NewEventPublisher(js, natsLogger)\n\n\t// Criar casos de uso\n\treceiveGoodsUC := app.NewReceiveGoodsUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tshipOrderUC := app.NewShipOrderUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tregisterReturnUC := app.NewRegisterReturnUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\tcompleteTransferUC := app.NewCompleteTransferUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\topenCycleCountUC := app.NewOpenCycleCountUseCase(repo, eventPublisher, appLogger)\n\tsubmitCycleCountUC := app.NewSubmitCycleCountUseCase(repo, inventoryClient, eventPublisher, appLogger)\n\n\t// Iniciar subscriber NATS para eventos OMS\n\tsubscriber := natsAdapter.NewFulfillmentSubscriber(js, shipOrderUC, natsLogger)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tif err := subscriber.Start(ctx); err != nil {\n\t\tlogger.Fatal(\"Failed to start NATS subscriber\", zap.Error(err))\n\t}\n\tlogger.Info(\"NATS subscriber started\")\n\n\t// Configurar router HTTP\n\trouter := httpHandler.Router(\n\t\treceiveGoodsUC,\n\t\tshipOrderUC,\n\t\tregisterReturnUC,\n\t\tcompleteTransferUC,\n\t\topenCycleCountUC,\n\t\tsubmitCycleCountUC,\n\t)\n\n\t// Configurar servidor HTTP\n\tsrv := \u0026http.Server{\n\t\tAddr:         httpPort,\n\t\tHandler:      router,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tIdleTimeout:  120 * time.Second,\n\t}\n\n\t// Iniciar servidor em goroutine\n\tgo func() {\n\t\tlogger.Info(\"Starting HTTP server\", zap.String(\"addr\", srv.Addr))\n\t\tif err := srv.ListenAndServe(); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlogger.Fatal(\"Failed to start server\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// Graceful shutdown\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-quit\n\n\tlogger.Info(\"Shutting down server...\")\n\n\tshutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer shutdownCancel()\n\n\tif err := srv.Shutdown(shutdownCtx); err != nil {\n\t\tlogger.Error(\"Server forced to shutdown\", zap.Error(err))\n\t}\n\n\tcancel() // Cancela contexto do subscriber\n\n\tlogger.Info(\"Server exited\")\n}",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "database/sql",
            "fmt",
            "net/http",
            "os",
            "os/signal",
            "syscall",
            "time",
            "github.com/gin-gonic/gin",
            "\"github.com/lib/pq",
            "github.com/nats-io/nats.go",
            "github.com/nats-io/nats.go/jetstream",
            "go.uber.org/zap",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/nats",
            "github.com/vertikon/mcp-fulfillment-ops/internal/adapters/postgres",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/adapters/redis",
            "github.com/vertikon/mcp-fulfillment-ops/internal/app",
            "\"github.com/vertikon/mcp-fulfillment-ops/internal/interfaces/http"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\n    10 | \t// Invoke invokes a cloud function\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\n    12 | \n    13 | \t// CreateFunction creates a cloud function\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\n    15 | \n    16 | \t// DeleteFunction deletes a cloud function\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\n    18 | }\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 42,
          "code_snippet": "    37 | func init() {\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\nâ†’   42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\n    43 | \trootCmd.AddCommand(ci.CICmd)\n    44 | }\n    45 | \n    46 | // GetRootCmd returns the root command (for testing)\n    47 | func GetRootCmd() *cobra.Command {\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\interfaces\\cli\\root.go",
          "line_number": 43,
          "code_snippet": "    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n    40 | \n    41 | \t// Add subcommand groups\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\nâ†’   43 | \trootCmd.AddCommand(ci.CICmd)\n    44 | }\n    45 | \n    46 | // GetRootCmd returns the root command (for testing)\n    47 | func GetRootCmd() *cobra.Command {\n    48 | \treturn rootCmd\n",
          "full_function": "func init() {\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\n\n\t// Add subcommand groups\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\n\trootCmd.AddCommand(ci.CICmd)\n}",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 215,
          "code_snippet": "   210 | \t\t\tif ruleCfg.Effect == \"deny\" {\n   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\nâ†’  215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\t\t\teffect = rbac.EffectDeny\n   212 | \t\t\t}\n   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\nâ†’  216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\n   218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\security\\config\\integration.go",
          "line_number": 218,
          "code_snippet": "   213 | \n   214 | \t\t\trule := rbac.PolicyRule{\n   215 | \t\t\t\tResource:    ruleCfg.Resource,\n   216 | \t\t\t\tAction:      ruleCfg.Action,\n   217 | \t\t\t\tEffect:      effect,\nâ†’  218 | \t\t\t\tDescription: ruleCfg.Description,\n   219 | \t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n   220 | \t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n   221 | \t\t\t\tConditions: []rbac.PolicyCondition{},\n   222 | \t\t\t}\n   223 | \t\t\tpolicy.Rules = append(policy.Rules, rule)\n",
          "full_function": "func LoadAndInitializeRBAC(loader *Loader) (rbac.RBACManager, error) {\n\tcfg, err := loader.LoadRBACConfig()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load RBAC config: %w\", err)\n\t}\n\n\t// Initialize Role Manager\n\troleStore := rbac.NewInMemoryRoleStore()\n\troleManager := rbac.NewRoleManager(roleStore)\n\n\t// Load roles from config\n\tctx := context.Background()\n\tfor _, roleCfg := range cfg.Roles {\n\t\trole := \u0026rbac.Role{\n\t\t\tID:          roleCfg.ID,\n\t\t\tName:        roleCfg.Name,\n\t\t\tDescription: roleCfg.Description,\n\t\t}\n\n\t\t// Convert permissions\n\t\tfor _, permCfg := range roleCfg.Permissions {\n\t\t\trole.Permissions = append(role.Permissions, rbac.Permission{\n\t\t\t\tResource: permCfg.Resource,\n\t\t\t\tAction:   permCfg.Action,\n\t\t\t})\n\t\t}\n\n\t\tif err := roleManager.CreateRole(ctx, role); err != nil {\n\t\t\tlogger.Warn(\"Failed to create role from config\",\n\t\t\t\tzap.String(\"role_id\", roleCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize Permission Checker\n\tpermissionChecker := rbac.NewPermissionChecker()\n\n\t// Register overrides\n\tfor _, overrideCfg := range cfg.Overrides {\n\t\t// Convert effect string to PolicyEffect\n\t\teffect := rbac.EffectAllow\n\t\tif overrideCfg.Effect == \"deny\" {\n\t\t\teffect = rbac.EffectDeny\n\t\t}\n\t\toverride := rbac.PermissionOverride{\n\t\t\tResourcePattern: overrideCfg.Resource,\n\t\t\tActionPattern:   overrideCfg.Action,\n\t\t\tEffect:          effect,\n\t\t}\n\t\tpermissionChecker.RegisterOverride(override)\n\t}\n\n\t// Initialize Policy Enforcer\n\tpolicyEnforcer := rbac.NewPolicyEnforcer(rbac.PolicyEnforcerConfig{})\n\n\t// Load policies from config\n\t// Note: Full policy loading requires proper PolicyCondition construction\n\t// This is a simplified version - full implementation would parse conditions properly\n\tfor _, policyCfg := range cfg.Policies {\n\t\tpolicy := \u0026rbac.Policy{\n\t\t\tID:          policyCfg.ID,\n\t\t\tDescription: policyCfg.Description,\n\t\t\tPriority:    policyCfg.Priority,\n\t\t}\n\n\t\t// Convert rules - simplified version\n\t\t// Full implementation would need to construct PolicyCondition objects\n\t\tfor _, ruleCfg := range policyCfg.Rules {\n\t\t\t// Convert effect string to PolicyEffect\n\t\t\teffect := rbac.EffectAllow\n\t\t\tif ruleCfg.Effect == \"deny\" {\n\t\t\t\teffect = rbac.EffectDeny\n\t\t\t}\n\n\t\t\trule := rbac.PolicyRule{\n\t\t\t\tResource:    ruleCfg.Resource,\n\t\t\t\tAction:      ruleCfg.Action,\n\t\t\t\tEffect:      effect,\n\t\t\t\tDescription: ruleCfg.Description,\n\t\t\t\t// Conditions would need to be constructed from ruleCfg.Condition and ruleCfg.Params\n\t\t\t\t// For now, we'll leave it empty - full implementation would parse conditions\n\t\t\t\tConditions: []rbac.PolicyCondition{},\n\t\t\t}\n\t\t\tpolicy.Rules = append(policy.Rules, rule)\n\t\t}\n\n\t\tif err := policyEnforcer.Register(policy); err != nil {\n\t\t\tlogger.Warn(\"Failed to register policy from config\",\n\t\t\t\tzap.String(\"policy_id\", policyCfg.ID),\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Initialize RBAC Manager\n\trbacManager := rbac.NewRBACManager(roleManager, permissionChecker, policyEnforcer)\n\n\tlogger.Info(\"RBAC configuration loaded and initialized\",\n\t\tzap.Int(\"roles_count\", len(cfg.Roles)),\n\t\tzap.Int(\"policies_count\", len(cfg.Policies)),\n\t\tzap.Int(\"overrides_count\", len(cfg.Overrides)),\n\t)\n\n\treturn rbacManager, nil\n}",
          "symbol_name": "",
          "package_name": "config",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/auth",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/encryption",
            "github.com/vertikon/mcp-fulfillment-ops/internal/security/rbac",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\n   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \n   234 | \tswitch comparison {\n   235 | \tcase \"local_greater\":\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n   237 | \tcase \"remote_greater\":\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n   239 | \tcase \"concurrent\":\n   240 | \t\t// Conflict detected, need merge\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\n   242 | \tdefault:\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\n\t// Extract vector clocks from metadata\n\tlocalVC := r.getVectorClock(conflict.LocalState)\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\n\n\t// Compare vector clocks\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\n\n\tswitch comparison {\n\tcase \"local_greater\":\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\n\tcase \"remote_greater\":\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\n\tcase \"concurrent\":\n\t\t// Conflict detected, need merge\n\t\treturn r.resolveCRDTMerge(conflict)\n\tdefault:\n\t\t// Same vector clock, use timestamp as tie-breaker\n\t\treturn r.resolveLastWriteWins(conflict)\n\t}\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\n   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n   253 | \n   254 | \t// Ensure both states have timestamps\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n   257 | \n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\n\t// CRDT LWW uses timestamps for conflict resolution\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\n\n\t// Ensure both states have timestamps\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\n\n\tif localTS.After(remoteTS) {\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   conflict.LocalState.Value,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     conflict.LocalState.TTL,\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t\t}, nil\n\t}\n\n\treturn \u0026VersionedState{\n\t\tKey:     conflict.Key,\n\t\tValue:   conflict.RemoteState.Value,\n\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\tTTL:     conflict.RemoteState.TTL,\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n   279 | \t// For simple values, use last-write-wins\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\n   281 | \n   282 | \t// Check if values are mergeable\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n   285 | \t\tif err != nil {\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\n   288 | \t\t\t\tzap.Error(err))\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\n\t// For simple values, use last-write-wins\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\n\n\t// Check if values are mergeable\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\n\t\tif err != nil {\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\n\t\t\t\tzap.String(\"key\", conflict.Key),\n\t\t\t\tzap.Error(err))\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\n\t\t}\n\n\t\treturn \u0026VersionedState{\n\t\t\tKey:     conflict.Key,\n\t\t\tValue:   mergedValue,\n\t\t\tVersion: max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\n\t\t}, nil\n\t}\n\n\t// Non-mergeable, fall back to LWW\n\treturn r.resolveCRDTLastWriterWins(conflict)\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\n   392 | }\n   393 | \n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\n   395 | \t// Check if value is a type that can be merged\nâ†’  396 | \tswitch v := value.(type) {\n   397 | \tcase map[string]interface{}:\n   398 | \t\treturn true\n   399 | \tcase []interface{}:\n   400 | \t\treturn true\n   401 | \tcase map[string]string:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\n   411 | \t// Implement actual CRDT merge logic based on value type\n   412 | \tswitch l := local.(type) {\n   413 | \tcase map[string]interface{}:\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\n   416 | \t\t}\n   417 | \tcase []interface{}:\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\n   420 | \t\t}\n   421 | \t}\n   422 | \n   423 | \t// Cannot merge, return error\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\n   158 | \tcm.stats.InvalidationsByReason[reason]++\n   159 | \tcm.mu.Unlock()\n   160 | \n   161 | \t// Delete from cache\nâ†’  162 | \tcm.cache.Delete(key)\n   163 | \n   164 | \t// Create invalidation event\n   165 | \tevent := \u0026InvalidationEvent{\n   166 | \t\tKey:       key,\n   167 | \t\tReason:    reason,\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\n\tstart := time.Now()\n\n\tcm.mu.Lock()\n\tcm.stats.TotalInvalidations++\n\tcm.stats.InvalidationsByReason[reason]++\n\tcm.mu.Unlock()\n\n\t// Delete from cache\n\tcm.cache.Delete(key)\n\n\t// Create invalidation event\n\tevent := \u0026InvalidationEvent{\n\t\tKey:       key,\n\t\tReason:    reason,\n\t\tTimestamp: time.Now(),\n\t\tSource:    \"coherency_manager\",\n\t}\n\n\t// Send to invalidation channel\n\tselect {\n\tcase cm.invalidationCh \u003c- event:\n\tdefault:\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\n\t\t\tzap.String(\"key\", key))\n\t}\n\n\tcm.mu.Lock()\n\tcm.stats.AverageInvalidationTime = time.Since(start)\n\tlastTime := time.Now()\n\tcm.stats.LastInvalidation = \u0026lastTime\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Cache key invalidated\",\n\t\tzap.String(\"key\", key),\n\t\tzap.String(\"reason\", reason))\n\n\treturn nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\n   213 | \n   214 | // Update updates a cache entry\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\n   216 | \tcm.mu.Lock()\nâ†’  217 | \tcm.stats.TotalUpdates++\n   218 | \tcm.mu.Unlock()\n   219 | \n   220 | \t// Update cache based on strategy\n   221 | \tswitch cm.config.Strategy {\n   222 | \tcase CoherencyStrategyWriteThrough:\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\n   249 | \t\tLevel:                cm.config.Level,\n   250 | \t\tIsCoherent:           true, // Simplified\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\n   254 | \t}, nil\n   255 | }\n   256 | \n   257 | // GetInvalidationStats returns invalidation statistics\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\treturn \u0026CoherencyStatus{\n\t\tStrategy:             cm.config.Strategy,\n\t\tLevel:                cm.config.Level,\n\t\tIsCoherent:           true, // Simplified\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\n\t}, nil\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\n   338 | \tcm.pendingInvalidations[event.Key] = event\n   339 | \tcm.mu.Unlock()\n   340 | \n   341 | \t// Process invalidation\nâ†’  342 | \tcm.cache.Delete(event.Key)\n   343 | \n   344 | \tcm.mu.Lock()\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\n   346 | \tcm.mu.Unlock()\n   347 | \n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\n\tcm.mu.Lock()\n\tcm.pendingInvalidations[event.Key] = event\n\tcm.mu.Unlock()\n\n\t// Process invalidation\n\tcm.cache.Delete(event.Key)\n\n\tcm.mu.Lock()\n\tdelete(cm.pendingInvalidations, event.Key)\n\tcm.mu.Unlock()\n\n\tcm.logger.Debug(\"Invalidation processed\",\n\t\tzap.String(\"key\", event.Key),\n\t\tzap.String(\"reason\", event.Reason))\n}",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\n   245 | \n   246 | // ReplayFromSnapshot replays events from a snapshot version\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n   248 | \t// Get snapshot\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n   250 | \tif err != nil {\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n   252 | \t}\n   253 | \n   254 | \t// Get events after snapshot version\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\n\t// Get snapshot\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\n\t}\n\n\t// Get events after snapshot version\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\n\t}\n\n\tif len(events) == 0 {\n\t\treturn \u0026ReplayProgress{\n\t\t\tTotalEvents:     0,\n\t\t\tProcessedEvents: 0,\n\t\t\tIsComplete:      true,\n\t\t}, nil\n\t}\n\n\tstartTime := time.Now()\n\tprogress := \u0026ReplayProgress{\n\t\tTotalEvents:    int64(len(events)),\n\t\tStartTime:      startTime,\n\t\tCurrentVersion: snapshotVersion + 1,\n\t}\n\n\terr = er.replaySequential(ctx, events, handler, progress)\n\tprogress.ElapsedTime = time.Since(startTime)\n\tprogress.IsComplete = true\n\n\tif err != nil {\n\t\tprogress.LastError = err.Error()\n\t\treturn progress, err\n\t}\n\n\treturn progress, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\n   286 | \n   287 | // ReplayToState replays events to rebuild state at a specific version\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\n   289 | \t// Get all events up to target version\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\n   291 | \tif err != nil {\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\n   293 | \t}\n   294 | \n   295 | \t// Replay events\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\n   136 | \t\t// Return copy\n   137 | \t\tcopy := *versionInfo\n   138 | \t\tif versionInfo.VersionHistory != nil {\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n   141 | \t\t}\n   142 | \t\treturn \u0026copy, nil\n   143 | \t}\n   144 | \n   145 | \t// Load from event store\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\n\tev.mu.RLock()\n\tversionInfo, exists := ev.versions[aggregateID]\n\tev.mu.RUnlock()\n\n\tif exists {\n\t\t// Return copy\n\t\tcopy := *versionInfo\n\t\tif versionInfo.VersionHistory != nil {\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\n\t\t}\n\t\treturn \u0026copy, nil\n\t}\n\n\t// Load from event store\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t}\n\n\tversionInfo = \u0026VersionInfo{\n\t\tAggregateID:    aggregateID,\n\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\tCurrentVersion: aggregateInfo.Version,\n\t\tMetadata:       make(map[string]interface{}),\n\t}\n\n\tif ev.config.EnableHistory {\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t}\n\n\tev.mu.Lock()\n\tev.versions[aggregateID] = versionInfo\n\tev.mu.Unlock()\n\n\treturn versionInfo, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n   213 | \t\t}\n   214 | \n   215 | \t\t// Resolve conflict\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n   217 | \t\tif err != nil {\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n   219 | \t\t}\n   220 | \n   221 | \t\tnewVersion = resolvedVersion\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\n\tev.mu.Lock()\n\tdefer ev.mu.Unlock()\n\n\tversionInfo, exists := ev.versions[aggregateID]\n\tif !exists {\n\t\t// Load from store\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\n\t\t}\n\n\t\tversionInfo = \u0026VersionInfo{\n\t\t\tAggregateID:    aggregateID,\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\n\t\t\tCurrentVersion: aggregateInfo.Version,\n\t\t\tMetadata:       make(map[string]interface{}),\n\t\t}\n\n\t\tif ev.config.EnableHistory {\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\n\t\t}\n\n\t\tev.versions[aggregateID] = versionInfo\n\t}\n\n\t// Increment version\n\tnewVersion := versionInfo.CurrentVersion + 1\n\n\t// Validate version continuity\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\n\t\tconflict := \u0026VersionConflict{\n\t\t\tAggregateID:     aggregateID,\n\t\t\tExpectedVersion: newVersion,\n\t\t\tActualVersion:   event.Version,\n\t\t\tConflictTime:    time.Now(),\n\t\t}\n\n\t\tev.stats.TotalConflicts++\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\n\n\t\tif ev.config.ConflictResolution == \"reject\" {\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\n\t\t}\n\n\t\t// Resolve conflict\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\n\t\t}\n\n\t\tnewVersion = resolvedVersion\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\n\t\tev.stats.ResolvedConflicts++\n\t}\n\n\t// Update version info\n\tversionInfo.CurrentVersion = newVersion\n\tversionInfo.LastEventID = event.ID\n\tversionInfo.LastEventTime = event.Timestamp\n\n\t// Add to history\n\tif ev.config.EnableHistory {\n\t\tentry := VersionHistoryEntry{\n\t\t\tVersion:   newVersion,\n\t\t\tEventID:   event.ID,\n\t\t\tTimestamp: event.Timestamp,\n\t\t\tEventType: event.Type,\n\t\t}\n\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\n\n\t\t// Trim history if needed\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\n\t\t}\n\t}\n\n\t// Update statistics\n\tev.stats.TotalVersions++\n\tev.stats.VersionDistribution[newVersion]++\n\n\tev.logger.Debug(\"Version incremented\",\n\t\tzap.String(\"aggregate_id\", aggregateID),\n\t\tzap.Int64(\"version\", newVersion))\n\n\treturn newVersion, nil\n}",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-fulfillment-ops\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\n     6 | \t\"os\"\n     7 | \t\"path/filepath\"\n     8 | \t\"time\"\n     9 | \nâ†’   10 | \t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n    11 | \t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n    12 | \t\"go.uber.org/zap\"\n    13 | )\n    14 | \n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n",
          "full_function": "\t\"github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes\"\n\t\"github.com/vertikon/mcp-fulfillment-ops/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\ntype HybridDeployer struct {\n\tdockerDeployer     *DockerDeployer\n\tkubernetesDeployer *KubernetesDeployer\n\tserverlessDeployer *ServerlessDeployer\n\tlogger             *zap.Logger\n}",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-fulfillment-ops/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-fulfillment-ops/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 11,
        "affected_lines": 38,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "30-60 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    }
  ],
  "technical_debt": null,
  "recommended_tools": [
    {
      "tool_name": "golangci-lint",
      "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
      "diagnose_command": "golangci-lint run",
      "fix_command": "# NAO use --fix automaticamente, revise cada issue",
      "config_required": true,
      "config_template": ".golangci.yml com linters selecionados",
      "documentation": "https://golangci-lint.run/",
      "alternative_tools": null
    },
    {
      "tool_name": "staticcheck",
      "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
      "diagnose_command": "staticcheck ./...",
      "fix_command": "# Manual - staticcheck nao tem auto-fix",
      "config_required": false,
      "config_template": "",
      "documentation": "https://staticcheck.io/",
      "alternative_tools": null
    },
    {
      "tool_name": "gosec",
      "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
      "diagnose_command": "gosec ./...",
      "fix_command": "# Manual - corrija issues de seguranca",
      "config_required": false,
      "config_template": "",
      "documentation": "https://github.com/securego/gosec",
      "alternative_tools": null
    }
  ],
  "next_steps": [
    "ðŸ”´ URGENTE: Resolver 2 bloqueador(es)"
  ],
  "estimated_effort": "1h30m"
}